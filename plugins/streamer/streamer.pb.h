// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: streamer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_streamer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_streamer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_streamer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_streamer_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_streamer_2eproto;
namespace streamer {
class AudioSample;
struct AudioSampleDefaultTypeInternal;
extern AudioSampleDefaultTypeInternal _AudioSample_default_instance_;
class CallInfo;
struct CallInfoDefaultTypeInternal;
extern CallInfoDefaultTypeInternal _CallInfo_default_instance_;
class ConfigInfo;
struct ConfigInfoDefaultTypeInternal;
extern ConfigInfoDefaultTypeInternal _ConfigInfo_default_instance_;
class RecorderInfo;
struct RecorderInfoDefaultTypeInternal;
extern RecorderInfoDefaultTypeInternal _RecorderInfo_default_instance_;
class SignalInfo;
struct SignalInfoDefaultTypeInternal;
extern SignalInfoDefaultTypeInternal _SignalInfo_default_instance_;
class SourceInfo;
struct SourceInfoDefaultTypeInternal;
extern SourceInfoDefaultTypeInternal _SourceInfo_default_instance_;
class SystemInfo;
struct SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
}  // namespace streamer
PROTOBUF_NAMESPACE_OPEN
template<> ::streamer::AudioSample* Arena::CreateMaybeMessage<::streamer::AudioSample>(Arena*);
template<> ::streamer::CallInfo* Arena::CreateMaybeMessage<::streamer::CallInfo>(Arena*);
template<> ::streamer::ConfigInfo* Arena::CreateMaybeMessage<::streamer::ConfigInfo>(Arena*);
template<> ::streamer::RecorderInfo* Arena::CreateMaybeMessage<::streamer::RecorderInfo>(Arena*);
template<> ::streamer::SignalInfo* Arena::CreateMaybeMessage<::streamer::SignalInfo>(Arena*);
template<> ::streamer::SourceInfo* Arena::CreateMaybeMessage<::streamer::SourceInfo>(Arena*);
template<> ::streamer::SystemInfo* Arena::CreateMaybeMessage<::streamer::SystemInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace streamer {

enum RecorderInfo_RecorderState : int {
  RecorderInfo_RecorderState_Monitoring = 0,
  RecorderInfo_RecorderState_Recording = 1,
  RecorderInfo_RecorderState_Inactive = 2,
  RecorderInfo_RecorderState_Active = 3,
  RecorderInfo_RecorderState_RecorderInfo_RecorderState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecorderInfo_RecorderState_RecorderInfo_RecorderState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecorderInfo_RecorderState_IsValid(int value);
constexpr RecorderInfo_RecorderState RecorderInfo_RecorderState_RecorderState_MIN = RecorderInfo_RecorderState_Monitoring;
constexpr RecorderInfo_RecorderState RecorderInfo_RecorderState_RecorderState_MAX = RecorderInfo_RecorderState_Active;
constexpr int RecorderInfo_RecorderState_RecorderState_ARRAYSIZE = RecorderInfo_RecorderState_RecorderState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecorderInfo_RecorderState_descriptor();
template<typename T>
inline const std::string& RecorderInfo_RecorderState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecorderInfo_RecorderState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecorderInfo_RecorderState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecorderInfo_RecorderState_descriptor(), enum_t_value);
}
inline bool RecorderInfo_RecorderState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecorderInfo_RecorderState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecorderInfo_RecorderState>(
    RecorderInfo_RecorderState_descriptor(), name, value);
}
enum RecorderInfo_AudioFormat : int {
  RecorderInfo_AudioFormat_Float32 = 0,
  RecorderInfo_AudioFormat_Signed16 = 1,
  RecorderInfo_AudioFormat_Signed24 = 2,
  RecorderInfo_AudioFormat_Signed32 = 3,
  RecorderInfo_AudioFormat_Unsigned8 = 4,
  RecorderInfo_AudioFormat_RecorderInfo_AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RecorderInfo_AudioFormat_RecorderInfo_AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RecorderInfo_AudioFormat_IsValid(int value);
constexpr RecorderInfo_AudioFormat RecorderInfo_AudioFormat_AudioFormat_MIN = RecorderInfo_AudioFormat_Float32;
constexpr RecorderInfo_AudioFormat RecorderInfo_AudioFormat_AudioFormat_MAX = RecorderInfo_AudioFormat_Unsigned8;
constexpr int RecorderInfo_AudioFormat_AudioFormat_ARRAYSIZE = RecorderInfo_AudioFormat_AudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecorderInfo_AudioFormat_descriptor();
template<typename T>
inline const std::string& RecorderInfo_AudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecorderInfo_AudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecorderInfo_AudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecorderInfo_AudioFormat_descriptor(), enum_t_value);
}
inline bool RecorderInfo_AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecorderInfo_AudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecorderInfo_AudioFormat>(
    RecorderInfo_AudioFormat_descriptor(), name, value);
}
enum SignalInfo_SignalType : int {
  SignalInfo_SignalType_Normal = 0,
  SignalInfo_SignalType_Emergency = 1,
  SignalInfo_SignalType_EmergencyAck = 2,
  SignalInfo_SignalType_RadioCheck = 3,
  SignalInfo_SignalType_RadioCheckAck = 4,
  SignalInfo_SignalType_RadioStun = 5,
  SignalInfo_SignalType_RadioStunAck = 6,
  SignalInfo_SignalType_RadioRevive = 7,
  SignalInfo_SignalType_RadioReviveAck = 8,
  SignalInfo_SignalType_NormalPre = 9,
  SignalInfo_SignalType_EmergencyPre = 10,
  SignalInfo_SignalType_SignalInfo_SignalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignalInfo_SignalType_SignalInfo_SignalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignalInfo_SignalType_IsValid(int value);
constexpr SignalInfo_SignalType SignalInfo_SignalType_SignalType_MIN = SignalInfo_SignalType_Normal;
constexpr SignalInfo_SignalType SignalInfo_SignalType_SignalType_MAX = SignalInfo_SignalType_EmergencyPre;
constexpr int SignalInfo_SignalType_SignalType_ARRAYSIZE = SignalInfo_SignalType_SignalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalInfo_SignalType_descriptor();
template<typename T>
inline const std::string& SignalInfo_SignalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalInfo_SignalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalInfo_SignalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalInfo_SignalType_descriptor(), enum_t_value);
}
inline bool SignalInfo_SignalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalInfo_SignalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalInfo_SignalType>(
    SignalInfo_SignalType_descriptor(), name, value);
}
// ===================================================================

class AudioSample final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.AudioSample) */ {
 public:
  inline AudioSample() : AudioSample(nullptr) {}
  ~AudioSample() override;
  explicit PROTOBUF_CONSTEXPR AudioSample(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioSample(const AudioSample& from);
  AudioSample(AudioSample&& from) noexcept
    : AudioSample() {
    *this = ::std::move(from);
  }

  inline AudioSample& operator=(const AudioSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioSample& operator=(AudioSample&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioSample& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioSample* internal_default_instance() {
    return reinterpret_cast<const AudioSample*>(
               &_AudioSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AudioSample& a, AudioSample& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioSample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioSample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioSample>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioSample& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioSample& from) {
    AudioSample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioSample* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.AudioSample";
  }
  protected:
  explicit AudioSample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleFieldNumber = 2,
    kRecorderNumFieldNumber = 1,
  };
  // bytes sample = 2;
  void clear_sample();
  const std::string& sample() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample();
  PROTOBUF_NODISCARD std::string* release_sample();
  void set_allocated_sample(std::string* sample);
  private:
  const std::string& _internal_sample() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sample(const std::string& value);
  std::string* _internal_mutable_sample();
  public:

  // int32 recorder_num = 1;
  void clear_recorder_num();
  int32_t recorder_num() const;
  void set_recorder_num(int32_t value);
  private:
  int32_t _internal_recorder_num() const;
  void _internal_set_recorder_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.AudioSample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_;
    int32_t recorder_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class RecorderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.RecorderInfo) */ {
 public:
  inline RecorderInfo() : RecorderInfo(nullptr) {}
  ~RecorderInfo() override;
  explicit PROTOBUF_CONSTEXPR RecorderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderInfo(const RecorderInfo& from);
  RecorderInfo(RecorderInfo&& from) noexcept
    : RecorderInfo() {
    *this = ::std::move(from);
  }

  inline RecorderInfo& operator=(const RecorderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderInfo& operator=(RecorderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderInfo* internal_default_instance() {
    return reinterpret_cast<const RecorderInfo*>(
               &_RecorderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecorderInfo& a, RecorderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderInfo& from) {
    RecorderInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.RecorderInfo";
  }
  protected:
  explicit RecorderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecorderInfo_RecorderState RecorderState;
  static constexpr RecorderState Monitoring =
    RecorderInfo_RecorderState_Monitoring;
  static constexpr RecorderState Recording =
    RecorderInfo_RecorderState_Recording;
  static constexpr RecorderState Inactive =
    RecorderInfo_RecorderState_Inactive;
  static constexpr RecorderState Active =
    RecorderInfo_RecorderState_Active;
  static inline bool RecorderState_IsValid(int value) {
    return RecorderInfo_RecorderState_IsValid(value);
  }
  static constexpr RecorderState RecorderState_MIN =
    RecorderInfo_RecorderState_RecorderState_MIN;
  static constexpr RecorderState RecorderState_MAX =
    RecorderInfo_RecorderState_RecorderState_MAX;
  static constexpr int RecorderState_ARRAYSIZE =
    RecorderInfo_RecorderState_RecorderState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecorderState_descriptor() {
    return RecorderInfo_RecorderState_descriptor();
  }
  template<typename T>
  static inline const std::string& RecorderState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecorderState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecorderState_Name.");
    return RecorderInfo_RecorderState_Name(enum_t_value);
  }
  static inline bool RecorderState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecorderState* value) {
    return RecorderInfo_RecorderState_Parse(name, value);
  }

  typedef RecorderInfo_AudioFormat AudioFormat;
  static constexpr AudioFormat Float32 =
    RecorderInfo_AudioFormat_Float32;
  static constexpr AudioFormat Signed16 =
    RecorderInfo_AudioFormat_Signed16;
  static constexpr AudioFormat Signed24 =
    RecorderInfo_AudioFormat_Signed24;
  static constexpr AudioFormat Signed32 =
    RecorderInfo_AudioFormat_Signed32;
  static constexpr AudioFormat Unsigned8 =
    RecorderInfo_AudioFormat_Unsigned8;
  static inline bool AudioFormat_IsValid(int value) {
    return RecorderInfo_AudioFormat_IsValid(value);
  }
  static constexpr AudioFormat AudioFormat_MIN =
    RecorderInfo_AudioFormat_AudioFormat_MIN;
  static constexpr AudioFormat AudioFormat_MAX =
    RecorderInfo_AudioFormat_AudioFormat_MAX;
  static constexpr int AudioFormat_ARRAYSIZE =
    RecorderInfo_AudioFormat_AudioFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioFormat_descriptor() {
    return RecorderInfo_AudioFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioFormat_Name.");
    return RecorderInfo_AudioFormat_Name(enum_t_value);
  }
  static inline bool AudioFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioFormat* value) {
    return RecorderInfo_AudioFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRecorderTypeFieldNumber = 2,
    kIdFieldNumber = 4,
    kRecorderNumFieldNumber = 1,
    kSourceNumFieldNumber = 3,
    kRecorderDurationFieldNumber = 6,
    kRecorderCountFieldNumber = 5,
    kRecorderStateFieldNumber = 7,
    kStatusLenFieldNumber = 8,
    kStatusErrorFieldNumber = 9,
    kStatusSpikeFieldNumber = 10,
    kAudioSampleRateFieldNumber = 11,
    kAudioChannelsFieldNumber = 12,
    kAudioFormatFieldNumber = 13,
  };
  // string recorder_type = 2;
  void clear_recorder_type();
  const std::string& recorder_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recorder_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recorder_type();
  PROTOBUF_NODISCARD std::string* release_recorder_type();
  void set_allocated_recorder_type(std::string* recorder_type);
  private:
  const std::string& _internal_recorder_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recorder_type(const std::string& value);
  std::string* _internal_mutable_recorder_type();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int32 recorder_num = 1;
  void clear_recorder_num();
  int32_t recorder_num() const;
  void set_recorder_num(int32_t value);
  private:
  int32_t _internal_recorder_num() const;
  void _internal_set_recorder_num(int32_t value);
  public:

  // int32 source_num = 3;
  void clear_source_num();
  int32_t source_num() const;
  void set_source_num(int32_t value);
  private:
  int32_t _internal_source_num() const;
  void _internal_set_source_num(int32_t value);
  public:

  // double recorder_duration = 6;
  void clear_recorder_duration();
  double recorder_duration() const;
  void set_recorder_duration(double value);
  private:
  double _internal_recorder_duration() const;
  void _internal_set_recorder_duration(double value);
  public:

  // int32 recorder_count = 5;
  void clear_recorder_count();
  int32_t recorder_count() const;
  void set_recorder_count(int32_t value);
  private:
  int32_t _internal_recorder_count() const;
  void _internal_set_recorder_count(int32_t value);
  public:

  // .streamer.RecorderInfo.RecorderState recorder_state = 7;
  void clear_recorder_state();
  ::streamer::RecorderInfo_RecorderState recorder_state() const;
  void set_recorder_state(::streamer::RecorderInfo_RecorderState value);
  private:
  ::streamer::RecorderInfo_RecorderState _internal_recorder_state() const;
  void _internal_set_recorder_state(::streamer::RecorderInfo_RecorderState value);
  public:

  // double status_len = 8;
  void clear_status_len();
  double status_len() const;
  void set_status_len(double value);
  private:
  double _internal_status_len() const;
  void _internal_set_status_len(double value);
  public:

  // double status_error = 9;
  void clear_status_error();
  double status_error() const;
  void set_status_error(double value);
  private:
  double _internal_status_error() const;
  void _internal_set_status_error(double value);
  public:

  // double status_spike = 10;
  void clear_status_spike();
  double status_spike() const;
  void set_status_spike(double value);
  private:
  double _internal_status_spike() const;
  void _internal_set_status_spike(double value);
  public:

  // int32 audio_sample_rate = 11;
  void clear_audio_sample_rate();
  int32_t audio_sample_rate() const;
  void set_audio_sample_rate(int32_t value);
  private:
  int32_t _internal_audio_sample_rate() const;
  void _internal_set_audio_sample_rate(int32_t value);
  public:

  // int32 audio_channels = 12;
  void clear_audio_channels();
  int32_t audio_channels() const;
  void set_audio_channels(int32_t value);
  private:
  int32_t _internal_audio_channels() const;
  void _internal_set_audio_channels(int32_t value);
  public:

  // .streamer.RecorderInfo.AudioFormat audio_format = 13;
  void clear_audio_format();
  ::streamer::RecorderInfo_AudioFormat audio_format() const;
  void set_audio_format(::streamer::RecorderInfo_AudioFormat value);
  private:
  ::streamer::RecorderInfo_AudioFormat _internal_audio_format() const;
  void _internal_set_audio_format(::streamer::RecorderInfo_AudioFormat value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.RecorderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recorder_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int32_t recorder_num_;
    int32_t source_num_;
    double recorder_duration_;
    int32_t recorder_count_;
    int recorder_state_;
    double status_len_;
    double status_error_;
    double status_spike_;
    int32_t audio_sample_rate_;
    int32_t audio_channels_;
    int audio_format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class SourceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.SourceInfo) */ {
 public:
  inline SourceInfo() : SourceInfo(nullptr) {}
  ~SourceInfo() override;
  explicit PROTOBUF_CONSTEXPR SourceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceInfo(const SourceInfo& from);
  SourceInfo(SourceInfo&& from) noexcept
    : SourceInfo() {
    *this = ::std::move(from);
  }

  inline SourceInfo& operator=(const SourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceInfo& operator=(SourceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceInfo* internal_default_instance() {
    return reinterpret_cast<const SourceInfo*>(
               &_SourceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SourceInfo& a, SourceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceInfo& from) {
    SourceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.SourceInfo";
  }
  protected:
  explicit SourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverFieldNumber = 6,
    kDeviceFieldNumber = 7,
    kAntennaFieldNumber = 8,
    kMinHzFieldNumber = 2,
    kMaxHzFieldNumber = 3,
    kCenterHzFieldNumber = 4,
    kRateFieldNumber = 5,
    kSourceNumFieldNumber = 1,
    kMixGainFieldNumber = 10,
    kErrorFieldNumber = 9,
    kLnaGainFieldNumber = 11,
    kVga1GainFieldNumber = 12,
    kVga2GainFieldNumber = 13,
    kBbGainFieldNumber = 14,
    kGainFieldNumber = 15,
    kIfGainFieldNumber = 16,
    kAnalogRecordersFieldNumber = 17,
    kDigitalRecordersFieldNumber = 18,
    kDebugRecordersFieldNumber = 19,
    kSigmfRecordersFieldNumber = 20,
  };
  // string driver = 6;
  void clear_driver();
  const std::string& driver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* driver);
  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(const std::string& value);
  std::string* _internal_mutable_driver();
  public:

  // string device = 7;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // string antenna = 8;
  void clear_antenna();
  const std::string& antenna() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_antenna(ArgT0&& arg0, ArgT... args);
  std::string* mutable_antenna();
  PROTOBUF_NODISCARD std::string* release_antenna();
  void set_allocated_antenna(std::string* antenna);
  private:
  const std::string& _internal_antenna() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_antenna(const std::string& value);
  std::string* _internal_mutable_antenna();
  public:

  // double min_hz = 2;
  void clear_min_hz();
  double min_hz() const;
  void set_min_hz(double value);
  private:
  double _internal_min_hz() const;
  void _internal_set_min_hz(double value);
  public:

  // double max_hz = 3;
  void clear_max_hz();
  double max_hz() const;
  void set_max_hz(double value);
  private:
  double _internal_max_hz() const;
  void _internal_set_max_hz(double value);
  public:

  // double center_hz = 4;
  void clear_center_hz();
  double center_hz() const;
  void set_center_hz(double value);
  private:
  double _internal_center_hz() const;
  void _internal_set_center_hz(double value);
  public:

  // double rate = 5;
  void clear_rate();
  double rate() const;
  void set_rate(double value);
  private:
  double _internal_rate() const;
  void _internal_set_rate(double value);
  public:

  // int32 source_num = 1;
  void clear_source_num();
  int32_t source_num() const;
  void set_source_num(int32_t value);
  private:
  int32_t _internal_source_num() const;
  void _internal_set_source_num(int32_t value);
  public:

  // int32 mix_gain = 10;
  void clear_mix_gain();
  int32_t mix_gain() const;
  void set_mix_gain(int32_t value);
  private:
  int32_t _internal_mix_gain() const;
  void _internal_set_mix_gain(int32_t value);
  public:

  // double error = 9;
  void clear_error();
  double error() const;
  void set_error(double value);
  private:
  double _internal_error() const;
  void _internal_set_error(double value);
  public:

  // int32 lna_gain = 11;
  void clear_lna_gain();
  int32_t lna_gain() const;
  void set_lna_gain(int32_t value);
  private:
  int32_t _internal_lna_gain() const;
  void _internal_set_lna_gain(int32_t value);
  public:

  // int32 vga1_gain = 12;
  void clear_vga1_gain();
  int32_t vga1_gain() const;
  void set_vga1_gain(int32_t value);
  private:
  int32_t _internal_vga1_gain() const;
  void _internal_set_vga1_gain(int32_t value);
  public:

  // int32 vga2_gain = 13;
  void clear_vga2_gain();
  int32_t vga2_gain() const;
  void set_vga2_gain(int32_t value);
  private:
  int32_t _internal_vga2_gain() const;
  void _internal_set_vga2_gain(int32_t value);
  public:

  // int32 bb_gain = 14;
  void clear_bb_gain();
  int32_t bb_gain() const;
  void set_bb_gain(int32_t value);
  private:
  int32_t _internal_bb_gain() const;
  void _internal_set_bb_gain(int32_t value);
  public:

  // int32 gain = 15;
  void clear_gain();
  int32_t gain() const;
  void set_gain(int32_t value);
  private:
  int32_t _internal_gain() const;
  void _internal_set_gain(int32_t value);
  public:

  // int32 if_gain = 16;
  void clear_if_gain();
  int32_t if_gain() const;
  void set_if_gain(int32_t value);
  private:
  int32_t _internal_if_gain() const;
  void _internal_set_if_gain(int32_t value);
  public:

  // int32 analog_recorders = 17;
  void clear_analog_recorders();
  int32_t analog_recorders() const;
  void set_analog_recorders(int32_t value);
  private:
  int32_t _internal_analog_recorders() const;
  void _internal_set_analog_recorders(int32_t value);
  public:

  // int32 digital_recorders = 18;
  void clear_digital_recorders();
  int32_t digital_recorders() const;
  void set_digital_recorders(int32_t value);
  private:
  int32_t _internal_digital_recorders() const;
  void _internal_set_digital_recorders(int32_t value);
  public:

  // int32 debug_recorders = 19;
  void clear_debug_recorders();
  int32_t debug_recorders() const;
  void set_debug_recorders(int32_t value);
  private:
  int32_t _internal_debug_recorders() const;
  void _internal_set_debug_recorders(int32_t value);
  public:

  // int32 sigmf_recorders = 20;
  void clear_sigmf_recorders();
  int32_t sigmf_recorders() const;
  void set_sigmf_recorders(int32_t value);
  private:
  int32_t _internal_sigmf_recorders() const;
  void _internal_set_sigmf_recorders(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.SourceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr antenna_;
    double min_hz_;
    double max_hz_;
    double center_hz_;
    double rate_;
    int32_t source_num_;
    int32_t mix_gain_;
    double error_;
    int32_t lna_gain_;
    int32_t vga1_gain_;
    int32_t vga2_gain_;
    int32_t bb_gain_;
    int32_t gain_;
    int32_t if_gain_;
    int32_t analog_recorders_;
    int32_t digital_recorders_;
    int32_t debug_recorders_;
    int32_t sigmf_recorders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class SystemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.SystemInfo) */ {
 public:
  inline SystemInfo() : SystemInfo(nullptr) {}
  ~SystemInfo() override;
  explicit PROTOBUF_CONSTEXPR SystemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfo(const SystemInfo& from);
  SystemInfo(SystemInfo&& from) noexcept
    : SystemInfo() {
    *this = ::std::move(from);
  }

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SystemInfo& a, SystemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemInfo& from) {
    SystemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.SystemInfo";
  }
  protected:
  explicit SystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 13,
    kSystemTypeFieldNumber = 2,
    kSystemNameFieldNumber = 3,
    kTalkgroupsFileFieldNumber = 8,
    kBandplanFieldNumber = 14,
    kSystemNumFieldNumber = 1,
    kAudioArchiveFieldNumber = 4,
    kRecordUnknownFieldNumber = 6,
    kCallLogFieldNumber = 7,
    kQpskFieldNumber = 11,
    kAnalogLevelsFieldNumber = 9,
    kDigitalLevelsFieldNumber = 10,
    kSquelchDbFieldNumber = 12,
    kBandplanBaseFieldNumber = 16,
    kBandplanHighFieldNumber = 17,
    kBandfreqFieldNumber = 15,
    kBandplanOffsetFieldNumber = 19,
    kBandplanSpacingFieldNumber = 18,
  };
  // repeated double channels = 13;
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  private:
  double _internal_channels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_channels() const;
  void _internal_add_channels(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_channels();
  public:
  double channels(int index) const;
  void set_channels(int index, double value);
  void add_channels(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_channels();

  // string system_type = 2;
  void clear_system_type();
  const std::string& system_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_type();
  PROTOBUF_NODISCARD std::string* release_system_type();
  void set_allocated_system_type(std::string* system_type);
  private:
  const std::string& _internal_system_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_type(const std::string& value);
  std::string* _internal_mutable_system_type();
  public:

  // string system_name = 3;
  void clear_system_name();
  const std::string& system_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_name();
  PROTOBUF_NODISCARD std::string* release_system_name();
  void set_allocated_system_name(std::string* system_name);
  private:
  const std::string& _internal_system_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_name(const std::string& value);
  std::string* _internal_mutable_system_name();
  public:

  // string talkgroups_file = 8;
  void clear_talkgroups_file();
  const std::string& talkgroups_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_talkgroups_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_talkgroups_file();
  PROTOBUF_NODISCARD std::string* release_talkgroups_file();
  void set_allocated_talkgroups_file(std::string* talkgroups_file);
  private:
  const std::string& _internal_talkgroups_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_talkgroups_file(const std::string& value);
  std::string* _internal_mutable_talkgroups_file();
  public:

  // string bandplan = 14;
  void clear_bandplan();
  const std::string& bandplan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bandplan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bandplan();
  PROTOBUF_NODISCARD std::string* release_bandplan();
  void set_allocated_bandplan(std::string* bandplan);
  private:
  const std::string& _internal_bandplan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bandplan(const std::string& value);
  std::string* _internal_mutable_bandplan();
  public:

  // int32 system_num = 1;
  void clear_system_num();
  int32_t system_num() const;
  void set_system_num(int32_t value);
  private:
  int32_t _internal_system_num() const;
  void _internal_set_system_num(int32_t value);
  public:

  // bool audio_archive = 4;
  void clear_audio_archive();
  bool audio_archive() const;
  void set_audio_archive(bool value);
  private:
  bool _internal_audio_archive() const;
  void _internal_set_audio_archive(bool value);
  public:

  // bool record_unknown = 6;
  void clear_record_unknown();
  bool record_unknown() const;
  void set_record_unknown(bool value);
  private:
  bool _internal_record_unknown() const;
  void _internal_set_record_unknown(bool value);
  public:

  // bool call_log = 7;
  void clear_call_log();
  bool call_log() const;
  void set_call_log(bool value);
  private:
  bool _internal_call_log() const;
  void _internal_set_call_log(bool value);
  public:

  // bool qpsk = 11;
  void clear_qpsk();
  bool qpsk() const;
  void set_qpsk(bool value);
  private:
  bool _internal_qpsk() const;
  void _internal_set_qpsk(bool value);
  public:

  // double analog_levels = 9;
  void clear_analog_levels();
  double analog_levels() const;
  void set_analog_levels(double value);
  private:
  double _internal_analog_levels() const;
  void _internal_set_analog_levels(double value);
  public:

  // double digital_levels = 10;
  void clear_digital_levels();
  double digital_levels() const;
  void set_digital_levels(double value);
  private:
  double _internal_digital_levels() const;
  void _internal_set_digital_levels(double value);
  public:

  // double squelch_db = 12;
  void clear_squelch_db();
  double squelch_db() const;
  void set_squelch_db(double value);
  private:
  double _internal_squelch_db() const;
  void _internal_set_squelch_db(double value);
  public:

  // double bandplan_base = 16;
  void clear_bandplan_base();
  double bandplan_base() const;
  void set_bandplan_base(double value);
  private:
  double _internal_bandplan_base() const;
  void _internal_set_bandplan_base(double value);
  public:

  // double bandplan_high = 17;
  void clear_bandplan_high();
  double bandplan_high() const;
  void set_bandplan_high(double value);
  private:
  double _internal_bandplan_high() const;
  void _internal_set_bandplan_high(double value);
  public:

  // int32 bandfreq = 15;
  void clear_bandfreq();
  int32_t bandfreq() const;
  void set_bandfreq(int32_t value);
  private:
  int32_t _internal_bandfreq() const;
  void _internal_set_bandfreq(int32_t value);
  public:

  // int32 bandplan_offset = 19;
  void clear_bandplan_offset();
  int32_t bandplan_offset() const;
  void set_bandplan_offset(int32_t value);
  private:
  int32_t _internal_bandplan_offset() const;
  void _internal_set_bandplan_offset(int32_t value);
  public:

  // double bandplan_spacing = 18;
  void clear_bandplan_spacing();
  double bandplan_spacing() const;
  void set_bandplan_spacing(double value);
  private:
  double _internal_bandplan_spacing() const;
  void _internal_set_bandplan_spacing(double value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.SystemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > channels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr talkgroups_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bandplan_;
    int32_t system_num_;
    bool audio_archive_;
    bool record_unknown_;
    bool call_log_;
    bool qpsk_;
    double analog_levels_;
    double digital_levels_;
    double squelch_db_;
    double bandplan_base_;
    double bandplan_high_;
    int32_t bandfreq_;
    int32_t bandplan_offset_;
    double bandplan_spacing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class ConfigInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.ConfigInfo) */ {
 public:
  inline ConfigInfo() : ConfigInfo(nullptr) {}
  ~ConfigInfo() override;
  explicit PROTOBUF_CONSTEXPR ConfigInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigInfo(const ConfigInfo& from);
  ConfigInfo(ConfigInfo&& from) noexcept
    : ConfigInfo() {
    *this = ::std::move(from);
  }

  inline ConfigInfo& operator=(const ConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigInfo& operator=(ConfigInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigInfo* internal_default_instance() {
    return reinterpret_cast<const ConfigInfo*>(
               &_ConfigInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigInfo& a, ConfigInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigInfo& from) {
    ConfigInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.ConfigInfo";
  }
  protected:
  explicit ConfigInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 1,
    kSystemsFieldNumber = 2,
    kCaptureDirFieldNumber = 3,
    kUploadServerFieldNumber = 4,
    kInstanceIdFieldNumber = 7,
    kInstanceKeyFieldNumber = 8,
    kCallTimeoutFieldNumber = 5,
    kLogFileFieldNumber = 6,
    kBroadcastSignalsFieldNumber = 9,
  };
  // repeated .streamer.SourceInfo sources = 1;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::streamer::SourceInfo* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SourceInfo >*
      mutable_sources();
  private:
  const ::streamer::SourceInfo& _internal_sources(int index) const;
  ::streamer::SourceInfo* _internal_add_sources();
  public:
  const ::streamer::SourceInfo& sources(int index) const;
  ::streamer::SourceInfo* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SourceInfo >&
      sources() const;

  // repeated .streamer.SystemInfo systems = 2;
  int systems_size() const;
  private:
  int _internal_systems_size() const;
  public:
  void clear_systems();
  ::streamer::SystemInfo* mutable_systems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SystemInfo >*
      mutable_systems();
  private:
  const ::streamer::SystemInfo& _internal_systems(int index) const;
  ::streamer::SystemInfo* _internal_add_systems();
  public:
  const ::streamer::SystemInfo& systems(int index) const;
  ::streamer::SystemInfo* add_systems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SystemInfo >&
      systems() const;

  // string capture_dir = 3;
  void clear_capture_dir();
  const std::string& capture_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capture_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capture_dir();
  PROTOBUF_NODISCARD std::string* release_capture_dir();
  void set_allocated_capture_dir(std::string* capture_dir);
  private:
  const std::string& _internal_capture_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capture_dir(const std::string& value);
  std::string* _internal_mutable_capture_dir();
  public:

  // string upload_server = 4;
  void clear_upload_server();
  const std::string& upload_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upload_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upload_server();
  PROTOBUF_NODISCARD std::string* release_upload_server();
  void set_allocated_upload_server(std::string* upload_server);
  private:
  const std::string& _internal_upload_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upload_server(const std::string& value);
  std::string* _internal_mutable_upload_server();
  public:

  // string instance_id = 7;
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // string instance_key = 8;
  void clear_instance_key();
  const std::string& instance_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_key();
  PROTOBUF_NODISCARD std::string* release_instance_key();
  void set_allocated_instance_key(std::string* instance_key);
  private:
  const std::string& _internal_instance_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_key(const std::string& value);
  std::string* _internal_mutable_instance_key();
  public:

  // int32 call_timeout = 5;
  void clear_call_timeout();
  int32_t call_timeout() const;
  void set_call_timeout(int32_t value);
  private:
  int32_t _internal_call_timeout() const;
  void _internal_set_call_timeout(int32_t value);
  public:

  // bool log_file = 6;
  void clear_log_file();
  bool log_file() const;
  void set_log_file(bool value);
  private:
  bool _internal_log_file() const;
  void _internal_set_log_file(bool value);
  public:

  // bool broadcast_signals = 9;
  void clear_broadcast_signals();
  bool broadcast_signals() const;
  void set_broadcast_signals(bool value);
  private:
  bool _internal_broadcast_signals() const;
  void _internal_set_broadcast_signals(bool value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.ConfigInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SourceInfo > sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SystemInfo > systems_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capture_dir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upload_server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_key_;
    int32_t call_timeout_;
    bool log_file_;
    bool broadcast_signals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class CallInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.CallInfo) */ {
 public:
  inline CallInfo() : CallInfo(nullptr) {}
  ~CallInfo() override;
  explicit PROTOBUF_CONSTEXPR CallInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallInfo(const CallInfo& from);
  CallInfo(CallInfo&& from) noexcept
    : CallInfo() {
    *this = ::std::move(from);
  }

  inline CallInfo& operator=(const CallInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallInfo& operator=(CallInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallInfo* internal_default_instance() {
    return reinterpret_cast<const CallInfo*>(
               &_CallInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallInfo& a, CallInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CallInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallInfo& from) {
    CallInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.CallInfo";
  }
  protected:
  explicit CallInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallActiveFieldNumber = 1,
    kRecorderNumFieldNumber = 2,
    kCurrFreqFieldNumber = 4,
    kSystemNumFieldNumber = 3,
  };
  // bool call_active = 1;
  void clear_call_active();
  bool call_active() const;
  void set_call_active(bool value);
  private:
  bool _internal_call_active() const;
  void _internal_set_call_active(bool value);
  public:

  // int32 recorder_num = 2;
  void clear_recorder_num();
  int32_t recorder_num() const;
  void set_recorder_num(int32_t value);
  private:
  int32_t _internal_recorder_num() const;
  void _internal_set_recorder_num(int32_t value);
  public:

  // double curr_freq = 4;
  void clear_curr_freq();
  double curr_freq() const;
  void set_curr_freq(double value);
  private:
  double _internal_curr_freq() const;
  void _internal_set_curr_freq(double value);
  public:

  // int32 system_num = 3;
  void clear_system_num();
  int32_t system_num() const;
  void set_system_num(int32_t value);
  private:
  int32_t _internal_system_num() const;
  void _internal_set_system_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.CallInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool call_active_;
    int32_t recorder_num_;
    double curr_freq_;
    int32_t system_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// -------------------------------------------------------------------

class SignalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:streamer.SignalInfo) */ {
 public:
  inline SignalInfo() : SignalInfo(nullptr) {}
  ~SignalInfo() override;
  explicit PROTOBUF_CONSTEXPR SignalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalInfo(const SignalInfo& from);
  SignalInfo(SignalInfo&& from) noexcept
    : SignalInfo() {
    *this = ::std::move(from);
  }

  inline SignalInfo& operator=(const SignalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalInfo& operator=(SignalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalInfo* internal_default_instance() {
    return reinterpret_cast<const SignalInfo*>(
               &_SignalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignalInfo& a, SignalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalInfo& from) {
    SignalInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "streamer.SignalInfo";
  }
  protected:
  explicit SignalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SignalInfo_SignalType SignalType;
  static constexpr SignalType Normal =
    SignalInfo_SignalType_Normal;
  static constexpr SignalType Emergency =
    SignalInfo_SignalType_Emergency;
  static constexpr SignalType EmergencyAck =
    SignalInfo_SignalType_EmergencyAck;
  static constexpr SignalType RadioCheck =
    SignalInfo_SignalType_RadioCheck;
  static constexpr SignalType RadioCheckAck =
    SignalInfo_SignalType_RadioCheckAck;
  static constexpr SignalType RadioStun =
    SignalInfo_SignalType_RadioStun;
  static constexpr SignalType RadioStunAck =
    SignalInfo_SignalType_RadioStunAck;
  static constexpr SignalType RadioRevive =
    SignalInfo_SignalType_RadioRevive;
  static constexpr SignalType RadioReviveAck =
    SignalInfo_SignalType_RadioReviveAck;
  static constexpr SignalType NormalPre =
    SignalInfo_SignalType_NormalPre;
  static constexpr SignalType EmergencyPre =
    SignalInfo_SignalType_EmergencyPre;
  static inline bool SignalType_IsValid(int value) {
    return SignalInfo_SignalType_IsValid(value);
  }
  static constexpr SignalType SignalType_MIN =
    SignalInfo_SignalType_SignalType_MIN;
  static constexpr SignalType SignalType_MAX =
    SignalInfo_SignalType_SignalType_MAX;
  static constexpr int SignalType_ARRAYSIZE =
    SignalInfo_SignalType_SignalType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SignalType_descriptor() {
    return SignalInfo_SignalType_descriptor();
  }
  template<typename T>
  static inline const std::string& SignalType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SignalType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SignalType_Name.");
    return SignalInfo_SignalType_Name(enum_t_value);
  }
  static inline bool SignalType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SignalType* value) {
    return SignalInfo_SignalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignalingTypeFieldNumber = 2,
    kCallInfoFieldNumber = 4,
    kSystemInfoFieldNumber = 5,
    kRecorderInfoFieldNumber = 6,
    kUnitIdFieldNumber = 1,
    kSignalTypeFieldNumber = 3,
  };
  // string signaling_type = 2;
  void clear_signaling_type();
  const std::string& signaling_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signaling_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signaling_type();
  PROTOBUF_NODISCARD std::string* release_signaling_type();
  void set_allocated_signaling_type(std::string* signaling_type);
  private:
  const std::string& _internal_signaling_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signaling_type(const std::string& value);
  std::string* _internal_mutable_signaling_type();
  public:

  // .streamer.CallInfo call_info = 4;
  bool has_call_info() const;
  private:
  bool _internal_has_call_info() const;
  public:
  void clear_call_info();
  const ::streamer::CallInfo& call_info() const;
  PROTOBUF_NODISCARD ::streamer::CallInfo* release_call_info();
  ::streamer::CallInfo* mutable_call_info();
  void set_allocated_call_info(::streamer::CallInfo* call_info);
  private:
  const ::streamer::CallInfo& _internal_call_info() const;
  ::streamer::CallInfo* _internal_mutable_call_info();
  public:
  void unsafe_arena_set_allocated_call_info(
      ::streamer::CallInfo* call_info);
  ::streamer::CallInfo* unsafe_arena_release_call_info();

  // .streamer.SystemInfo system_info = 5;
  bool has_system_info() const;
  private:
  bool _internal_has_system_info() const;
  public:
  void clear_system_info();
  const ::streamer::SystemInfo& system_info() const;
  PROTOBUF_NODISCARD ::streamer::SystemInfo* release_system_info();
  ::streamer::SystemInfo* mutable_system_info();
  void set_allocated_system_info(::streamer::SystemInfo* system_info);
  private:
  const ::streamer::SystemInfo& _internal_system_info() const;
  ::streamer::SystemInfo* _internal_mutable_system_info();
  public:
  void unsafe_arena_set_allocated_system_info(
      ::streamer::SystemInfo* system_info);
  ::streamer::SystemInfo* unsafe_arena_release_system_info();

  // .streamer.RecorderInfo recorder_info = 6;
  bool has_recorder_info() const;
  private:
  bool _internal_has_recorder_info() const;
  public:
  void clear_recorder_info();
  const ::streamer::RecorderInfo& recorder_info() const;
  PROTOBUF_NODISCARD ::streamer::RecorderInfo* release_recorder_info();
  ::streamer::RecorderInfo* mutable_recorder_info();
  void set_allocated_recorder_info(::streamer::RecorderInfo* recorder_info);
  private:
  const ::streamer::RecorderInfo& _internal_recorder_info() const;
  ::streamer::RecorderInfo* _internal_mutable_recorder_info();
  public:
  void unsafe_arena_set_allocated_recorder_info(
      ::streamer::RecorderInfo* recorder_info);
  ::streamer::RecorderInfo* unsafe_arena_release_recorder_info();

  // int64 unit_id = 1;
  void clear_unit_id();
  int64_t unit_id() const;
  void set_unit_id(int64_t value);
  private:
  int64_t _internal_unit_id() const;
  void _internal_set_unit_id(int64_t value);
  public:

  // .streamer.SignalInfo.SignalType signal_type = 3;
  void clear_signal_type();
  ::streamer::SignalInfo_SignalType signal_type() const;
  void set_signal_type(::streamer::SignalInfo_SignalType value);
  private:
  ::streamer::SignalInfo_SignalType _internal_signal_type() const;
  void _internal_set_signal_type(::streamer::SignalInfo_SignalType value);
  public:

  // @@protoc_insertion_point(class_scope:streamer.SignalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signaling_type_;
    ::streamer::CallInfo* call_info_;
    ::streamer::SystemInfo* system_info_;
    ::streamer::RecorderInfo* recorder_info_;
    int64_t unit_id_;
    int signal_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_streamer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AudioSample

// int32 recorder_num = 1;
inline void AudioSample::clear_recorder_num() {
  _impl_.recorder_num_ = 0;
}
inline int32_t AudioSample::_internal_recorder_num() const {
  return _impl_.recorder_num_;
}
inline int32_t AudioSample::recorder_num() const {
  // @@protoc_insertion_point(field_get:streamer.AudioSample.recorder_num)
  return _internal_recorder_num();
}
inline void AudioSample::_internal_set_recorder_num(int32_t value) {
  
  _impl_.recorder_num_ = value;
}
inline void AudioSample::set_recorder_num(int32_t value) {
  _internal_set_recorder_num(value);
  // @@protoc_insertion_point(field_set:streamer.AudioSample.recorder_num)
}

// bytes sample = 2;
inline void AudioSample::clear_sample() {
  _impl_.sample_.ClearToEmpty();
}
inline const std::string& AudioSample::sample() const {
  // @@protoc_insertion_point(field_get:streamer.AudioSample.sample)
  return _internal_sample();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioSample::set_sample(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sample_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.AudioSample.sample)
}
inline std::string* AudioSample::mutable_sample() {
  std::string* _s = _internal_mutable_sample();
  // @@protoc_insertion_point(field_mutable:streamer.AudioSample.sample)
  return _s;
}
inline const std::string& AudioSample::_internal_sample() const {
  return _impl_.sample_.Get();
}
inline void AudioSample::_internal_set_sample(const std::string& value) {
  
  _impl_.sample_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioSample::_internal_mutable_sample() {
  
  return _impl_.sample_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioSample::release_sample() {
  // @@protoc_insertion_point(field_release:streamer.AudioSample.sample)
  return _impl_.sample_.Release();
}
inline void AudioSample::set_allocated_sample(std::string* sample) {
  if (sample != nullptr) {
    
  } else {
    
  }
  _impl_.sample_.SetAllocated(sample, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sample_.IsDefault()) {
    _impl_.sample_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.AudioSample.sample)
}

// -------------------------------------------------------------------

// RecorderInfo

// int32 recorder_num = 1;
inline void RecorderInfo::clear_recorder_num() {
  _impl_.recorder_num_ = 0;
}
inline int32_t RecorderInfo::_internal_recorder_num() const {
  return _impl_.recorder_num_;
}
inline int32_t RecorderInfo::recorder_num() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.recorder_num)
  return _internal_recorder_num();
}
inline void RecorderInfo::_internal_set_recorder_num(int32_t value) {
  
  _impl_.recorder_num_ = value;
}
inline void RecorderInfo::set_recorder_num(int32_t value) {
  _internal_set_recorder_num(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.recorder_num)
}

// string recorder_type = 2;
inline void RecorderInfo::clear_recorder_type() {
  _impl_.recorder_type_.ClearToEmpty();
}
inline const std::string& RecorderInfo::recorder_type() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.recorder_type)
  return _internal_recorder_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderInfo::set_recorder_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recorder_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.recorder_type)
}
inline std::string* RecorderInfo::mutable_recorder_type() {
  std::string* _s = _internal_mutable_recorder_type();
  // @@protoc_insertion_point(field_mutable:streamer.RecorderInfo.recorder_type)
  return _s;
}
inline const std::string& RecorderInfo::_internal_recorder_type() const {
  return _impl_.recorder_type_.Get();
}
inline void RecorderInfo::_internal_set_recorder_type(const std::string& value) {
  
  _impl_.recorder_type_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderInfo::_internal_mutable_recorder_type() {
  
  return _impl_.recorder_type_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderInfo::release_recorder_type() {
  // @@protoc_insertion_point(field_release:streamer.RecorderInfo.recorder_type)
  return _impl_.recorder_type_.Release();
}
inline void RecorderInfo::set_allocated_recorder_type(std::string* recorder_type) {
  if (recorder_type != nullptr) {
    
  } else {
    
  }
  _impl_.recorder_type_.SetAllocated(recorder_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recorder_type_.IsDefault()) {
    _impl_.recorder_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.RecorderInfo.recorder_type)
}

// int32 source_num = 3;
inline void RecorderInfo::clear_source_num() {
  _impl_.source_num_ = 0;
}
inline int32_t RecorderInfo::_internal_source_num() const {
  return _impl_.source_num_;
}
inline int32_t RecorderInfo::source_num() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.source_num)
  return _internal_source_num();
}
inline void RecorderInfo::_internal_set_source_num(int32_t value) {
  
  _impl_.source_num_ = value;
}
inline void RecorderInfo::set_source_num(int32_t value) {
  _internal_set_source_num(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.source_num)
}

// string id = 4;
inline void RecorderInfo::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RecorderInfo::id() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.id)
}
inline std::string* RecorderInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:streamer.RecorderInfo.id)
  return _s;
}
inline const std::string& RecorderInfo::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RecorderInfo::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderInfo::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderInfo::release_id() {
  // @@protoc_insertion_point(field_release:streamer.RecorderInfo.id)
  return _impl_.id_.Release();
}
inline void RecorderInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.RecorderInfo.id)
}

// int32 recorder_count = 5;
inline void RecorderInfo::clear_recorder_count() {
  _impl_.recorder_count_ = 0;
}
inline int32_t RecorderInfo::_internal_recorder_count() const {
  return _impl_.recorder_count_;
}
inline int32_t RecorderInfo::recorder_count() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.recorder_count)
  return _internal_recorder_count();
}
inline void RecorderInfo::_internal_set_recorder_count(int32_t value) {
  
  _impl_.recorder_count_ = value;
}
inline void RecorderInfo::set_recorder_count(int32_t value) {
  _internal_set_recorder_count(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.recorder_count)
}

// double recorder_duration = 6;
inline void RecorderInfo::clear_recorder_duration() {
  _impl_.recorder_duration_ = 0;
}
inline double RecorderInfo::_internal_recorder_duration() const {
  return _impl_.recorder_duration_;
}
inline double RecorderInfo::recorder_duration() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.recorder_duration)
  return _internal_recorder_duration();
}
inline void RecorderInfo::_internal_set_recorder_duration(double value) {
  
  _impl_.recorder_duration_ = value;
}
inline void RecorderInfo::set_recorder_duration(double value) {
  _internal_set_recorder_duration(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.recorder_duration)
}

// .streamer.RecorderInfo.RecorderState recorder_state = 7;
inline void RecorderInfo::clear_recorder_state() {
  _impl_.recorder_state_ = 0;
}
inline ::streamer::RecorderInfo_RecorderState RecorderInfo::_internal_recorder_state() const {
  return static_cast< ::streamer::RecorderInfo_RecorderState >(_impl_.recorder_state_);
}
inline ::streamer::RecorderInfo_RecorderState RecorderInfo::recorder_state() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.recorder_state)
  return _internal_recorder_state();
}
inline void RecorderInfo::_internal_set_recorder_state(::streamer::RecorderInfo_RecorderState value) {
  
  _impl_.recorder_state_ = value;
}
inline void RecorderInfo::set_recorder_state(::streamer::RecorderInfo_RecorderState value) {
  _internal_set_recorder_state(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.recorder_state)
}

// double status_len = 8;
inline void RecorderInfo::clear_status_len() {
  _impl_.status_len_ = 0;
}
inline double RecorderInfo::_internal_status_len() const {
  return _impl_.status_len_;
}
inline double RecorderInfo::status_len() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.status_len)
  return _internal_status_len();
}
inline void RecorderInfo::_internal_set_status_len(double value) {
  
  _impl_.status_len_ = value;
}
inline void RecorderInfo::set_status_len(double value) {
  _internal_set_status_len(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.status_len)
}

// double status_error = 9;
inline void RecorderInfo::clear_status_error() {
  _impl_.status_error_ = 0;
}
inline double RecorderInfo::_internal_status_error() const {
  return _impl_.status_error_;
}
inline double RecorderInfo::status_error() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.status_error)
  return _internal_status_error();
}
inline void RecorderInfo::_internal_set_status_error(double value) {
  
  _impl_.status_error_ = value;
}
inline void RecorderInfo::set_status_error(double value) {
  _internal_set_status_error(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.status_error)
}

// double status_spike = 10;
inline void RecorderInfo::clear_status_spike() {
  _impl_.status_spike_ = 0;
}
inline double RecorderInfo::_internal_status_spike() const {
  return _impl_.status_spike_;
}
inline double RecorderInfo::status_spike() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.status_spike)
  return _internal_status_spike();
}
inline void RecorderInfo::_internal_set_status_spike(double value) {
  
  _impl_.status_spike_ = value;
}
inline void RecorderInfo::set_status_spike(double value) {
  _internal_set_status_spike(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.status_spike)
}

// int32 audio_sample_rate = 11;
inline void RecorderInfo::clear_audio_sample_rate() {
  _impl_.audio_sample_rate_ = 0;
}
inline int32_t RecorderInfo::_internal_audio_sample_rate() const {
  return _impl_.audio_sample_rate_;
}
inline int32_t RecorderInfo::audio_sample_rate() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.audio_sample_rate)
  return _internal_audio_sample_rate();
}
inline void RecorderInfo::_internal_set_audio_sample_rate(int32_t value) {
  
  _impl_.audio_sample_rate_ = value;
}
inline void RecorderInfo::set_audio_sample_rate(int32_t value) {
  _internal_set_audio_sample_rate(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.audio_sample_rate)
}

// int32 audio_channels = 12;
inline void RecorderInfo::clear_audio_channels() {
  _impl_.audio_channels_ = 0;
}
inline int32_t RecorderInfo::_internal_audio_channels() const {
  return _impl_.audio_channels_;
}
inline int32_t RecorderInfo::audio_channels() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.audio_channels)
  return _internal_audio_channels();
}
inline void RecorderInfo::_internal_set_audio_channels(int32_t value) {
  
  _impl_.audio_channels_ = value;
}
inline void RecorderInfo::set_audio_channels(int32_t value) {
  _internal_set_audio_channels(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.audio_channels)
}

// .streamer.RecorderInfo.AudioFormat audio_format = 13;
inline void RecorderInfo::clear_audio_format() {
  _impl_.audio_format_ = 0;
}
inline ::streamer::RecorderInfo_AudioFormat RecorderInfo::_internal_audio_format() const {
  return static_cast< ::streamer::RecorderInfo_AudioFormat >(_impl_.audio_format_);
}
inline ::streamer::RecorderInfo_AudioFormat RecorderInfo::audio_format() const {
  // @@protoc_insertion_point(field_get:streamer.RecorderInfo.audio_format)
  return _internal_audio_format();
}
inline void RecorderInfo::_internal_set_audio_format(::streamer::RecorderInfo_AudioFormat value) {
  
  _impl_.audio_format_ = value;
}
inline void RecorderInfo::set_audio_format(::streamer::RecorderInfo_AudioFormat value) {
  _internal_set_audio_format(value);
  // @@protoc_insertion_point(field_set:streamer.RecorderInfo.audio_format)
}

// -------------------------------------------------------------------

// SourceInfo

// int32 source_num = 1;
inline void SourceInfo::clear_source_num() {
  _impl_.source_num_ = 0;
}
inline int32_t SourceInfo::_internal_source_num() const {
  return _impl_.source_num_;
}
inline int32_t SourceInfo::source_num() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.source_num)
  return _internal_source_num();
}
inline void SourceInfo::_internal_set_source_num(int32_t value) {
  
  _impl_.source_num_ = value;
}
inline void SourceInfo::set_source_num(int32_t value) {
  _internal_set_source_num(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.source_num)
}

// double min_hz = 2;
inline void SourceInfo::clear_min_hz() {
  _impl_.min_hz_ = 0;
}
inline double SourceInfo::_internal_min_hz() const {
  return _impl_.min_hz_;
}
inline double SourceInfo::min_hz() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.min_hz)
  return _internal_min_hz();
}
inline void SourceInfo::_internal_set_min_hz(double value) {
  
  _impl_.min_hz_ = value;
}
inline void SourceInfo::set_min_hz(double value) {
  _internal_set_min_hz(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.min_hz)
}

// double max_hz = 3;
inline void SourceInfo::clear_max_hz() {
  _impl_.max_hz_ = 0;
}
inline double SourceInfo::_internal_max_hz() const {
  return _impl_.max_hz_;
}
inline double SourceInfo::max_hz() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.max_hz)
  return _internal_max_hz();
}
inline void SourceInfo::_internal_set_max_hz(double value) {
  
  _impl_.max_hz_ = value;
}
inline void SourceInfo::set_max_hz(double value) {
  _internal_set_max_hz(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.max_hz)
}

// double center_hz = 4;
inline void SourceInfo::clear_center_hz() {
  _impl_.center_hz_ = 0;
}
inline double SourceInfo::_internal_center_hz() const {
  return _impl_.center_hz_;
}
inline double SourceInfo::center_hz() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.center_hz)
  return _internal_center_hz();
}
inline void SourceInfo::_internal_set_center_hz(double value) {
  
  _impl_.center_hz_ = value;
}
inline void SourceInfo::set_center_hz(double value) {
  _internal_set_center_hz(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.center_hz)
}

// double rate = 5;
inline void SourceInfo::clear_rate() {
  _impl_.rate_ = 0;
}
inline double SourceInfo::_internal_rate() const {
  return _impl_.rate_;
}
inline double SourceInfo::rate() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.rate)
  return _internal_rate();
}
inline void SourceInfo::_internal_set_rate(double value) {
  
  _impl_.rate_ = value;
}
inline void SourceInfo::set_rate(double value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.rate)
}

// string driver = 6;
inline void SourceInfo::clear_driver() {
  _impl_.driver_.ClearToEmpty();
}
inline const std::string& SourceInfo::driver() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.driver)
  return _internal_driver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceInfo::set_driver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.driver)
}
inline std::string* SourceInfo::mutable_driver() {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:streamer.SourceInfo.driver)
  return _s;
}
inline const std::string& SourceInfo::_internal_driver() const {
  return _impl_.driver_.Get();
}
inline void SourceInfo::_internal_set_driver(const std::string& value) {
  
  _impl_.driver_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceInfo::_internal_mutable_driver() {
  
  return _impl_.driver_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceInfo::release_driver() {
  // @@protoc_insertion_point(field_release:streamer.SourceInfo.driver)
  return _impl_.driver_.Release();
}
inline void SourceInfo::set_allocated_driver(std::string* driver) {
  if (driver != nullptr) {
    
  } else {
    
  }
  _impl_.driver_.SetAllocated(driver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_.IsDefault()) {
    _impl_.driver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SourceInfo.driver)
}

// string device = 7;
inline void SourceInfo::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& SourceInfo::device() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceInfo::set_device(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.device)
}
inline std::string* SourceInfo::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:streamer.SourceInfo.device)
  return _s;
}
inline const std::string& SourceInfo::_internal_device() const {
  return _impl_.device_.Get();
}
inline void SourceInfo::_internal_set_device(const std::string& value) {
  
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceInfo::_internal_mutable_device() {
  
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceInfo::release_device() {
  // @@protoc_insertion_point(field_release:streamer.SourceInfo.device)
  return _impl_.device_.Release();
}
inline void SourceInfo::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SourceInfo.device)
}

// string antenna = 8;
inline void SourceInfo::clear_antenna() {
  _impl_.antenna_.ClearToEmpty();
}
inline const std::string& SourceInfo::antenna() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.antenna)
  return _internal_antenna();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceInfo::set_antenna(ArgT0&& arg0, ArgT... args) {
 
 _impl_.antenna_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.antenna)
}
inline std::string* SourceInfo::mutable_antenna() {
  std::string* _s = _internal_mutable_antenna();
  // @@protoc_insertion_point(field_mutable:streamer.SourceInfo.antenna)
  return _s;
}
inline const std::string& SourceInfo::_internal_antenna() const {
  return _impl_.antenna_.Get();
}
inline void SourceInfo::_internal_set_antenna(const std::string& value) {
  
  _impl_.antenna_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceInfo::_internal_mutable_antenna() {
  
  return _impl_.antenna_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceInfo::release_antenna() {
  // @@protoc_insertion_point(field_release:streamer.SourceInfo.antenna)
  return _impl_.antenna_.Release();
}
inline void SourceInfo::set_allocated_antenna(std::string* antenna) {
  if (antenna != nullptr) {
    
  } else {
    
  }
  _impl_.antenna_.SetAllocated(antenna, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.antenna_.IsDefault()) {
    _impl_.antenna_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SourceInfo.antenna)
}

// double error = 9;
inline void SourceInfo::clear_error() {
  _impl_.error_ = 0;
}
inline double SourceInfo::_internal_error() const {
  return _impl_.error_;
}
inline double SourceInfo::error() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.error)
  return _internal_error();
}
inline void SourceInfo::_internal_set_error(double value) {
  
  _impl_.error_ = value;
}
inline void SourceInfo::set_error(double value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.error)
}

// int32 mix_gain = 10;
inline void SourceInfo::clear_mix_gain() {
  _impl_.mix_gain_ = 0;
}
inline int32_t SourceInfo::_internal_mix_gain() const {
  return _impl_.mix_gain_;
}
inline int32_t SourceInfo::mix_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.mix_gain)
  return _internal_mix_gain();
}
inline void SourceInfo::_internal_set_mix_gain(int32_t value) {
  
  _impl_.mix_gain_ = value;
}
inline void SourceInfo::set_mix_gain(int32_t value) {
  _internal_set_mix_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.mix_gain)
}

// int32 lna_gain = 11;
inline void SourceInfo::clear_lna_gain() {
  _impl_.lna_gain_ = 0;
}
inline int32_t SourceInfo::_internal_lna_gain() const {
  return _impl_.lna_gain_;
}
inline int32_t SourceInfo::lna_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.lna_gain)
  return _internal_lna_gain();
}
inline void SourceInfo::_internal_set_lna_gain(int32_t value) {
  
  _impl_.lna_gain_ = value;
}
inline void SourceInfo::set_lna_gain(int32_t value) {
  _internal_set_lna_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.lna_gain)
}

// int32 vga1_gain = 12;
inline void SourceInfo::clear_vga1_gain() {
  _impl_.vga1_gain_ = 0;
}
inline int32_t SourceInfo::_internal_vga1_gain() const {
  return _impl_.vga1_gain_;
}
inline int32_t SourceInfo::vga1_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.vga1_gain)
  return _internal_vga1_gain();
}
inline void SourceInfo::_internal_set_vga1_gain(int32_t value) {
  
  _impl_.vga1_gain_ = value;
}
inline void SourceInfo::set_vga1_gain(int32_t value) {
  _internal_set_vga1_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.vga1_gain)
}

// int32 vga2_gain = 13;
inline void SourceInfo::clear_vga2_gain() {
  _impl_.vga2_gain_ = 0;
}
inline int32_t SourceInfo::_internal_vga2_gain() const {
  return _impl_.vga2_gain_;
}
inline int32_t SourceInfo::vga2_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.vga2_gain)
  return _internal_vga2_gain();
}
inline void SourceInfo::_internal_set_vga2_gain(int32_t value) {
  
  _impl_.vga2_gain_ = value;
}
inline void SourceInfo::set_vga2_gain(int32_t value) {
  _internal_set_vga2_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.vga2_gain)
}

// int32 bb_gain = 14;
inline void SourceInfo::clear_bb_gain() {
  _impl_.bb_gain_ = 0;
}
inline int32_t SourceInfo::_internal_bb_gain() const {
  return _impl_.bb_gain_;
}
inline int32_t SourceInfo::bb_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.bb_gain)
  return _internal_bb_gain();
}
inline void SourceInfo::_internal_set_bb_gain(int32_t value) {
  
  _impl_.bb_gain_ = value;
}
inline void SourceInfo::set_bb_gain(int32_t value) {
  _internal_set_bb_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.bb_gain)
}

// int32 gain = 15;
inline void SourceInfo::clear_gain() {
  _impl_.gain_ = 0;
}
inline int32_t SourceInfo::_internal_gain() const {
  return _impl_.gain_;
}
inline int32_t SourceInfo::gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.gain)
  return _internal_gain();
}
inline void SourceInfo::_internal_set_gain(int32_t value) {
  
  _impl_.gain_ = value;
}
inline void SourceInfo::set_gain(int32_t value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.gain)
}

// int32 if_gain = 16;
inline void SourceInfo::clear_if_gain() {
  _impl_.if_gain_ = 0;
}
inline int32_t SourceInfo::_internal_if_gain() const {
  return _impl_.if_gain_;
}
inline int32_t SourceInfo::if_gain() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.if_gain)
  return _internal_if_gain();
}
inline void SourceInfo::_internal_set_if_gain(int32_t value) {
  
  _impl_.if_gain_ = value;
}
inline void SourceInfo::set_if_gain(int32_t value) {
  _internal_set_if_gain(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.if_gain)
}

// int32 analog_recorders = 17;
inline void SourceInfo::clear_analog_recorders() {
  _impl_.analog_recorders_ = 0;
}
inline int32_t SourceInfo::_internal_analog_recorders() const {
  return _impl_.analog_recorders_;
}
inline int32_t SourceInfo::analog_recorders() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.analog_recorders)
  return _internal_analog_recorders();
}
inline void SourceInfo::_internal_set_analog_recorders(int32_t value) {
  
  _impl_.analog_recorders_ = value;
}
inline void SourceInfo::set_analog_recorders(int32_t value) {
  _internal_set_analog_recorders(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.analog_recorders)
}

// int32 digital_recorders = 18;
inline void SourceInfo::clear_digital_recorders() {
  _impl_.digital_recorders_ = 0;
}
inline int32_t SourceInfo::_internal_digital_recorders() const {
  return _impl_.digital_recorders_;
}
inline int32_t SourceInfo::digital_recorders() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.digital_recorders)
  return _internal_digital_recorders();
}
inline void SourceInfo::_internal_set_digital_recorders(int32_t value) {
  
  _impl_.digital_recorders_ = value;
}
inline void SourceInfo::set_digital_recorders(int32_t value) {
  _internal_set_digital_recorders(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.digital_recorders)
}

// int32 debug_recorders = 19;
inline void SourceInfo::clear_debug_recorders() {
  _impl_.debug_recorders_ = 0;
}
inline int32_t SourceInfo::_internal_debug_recorders() const {
  return _impl_.debug_recorders_;
}
inline int32_t SourceInfo::debug_recorders() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.debug_recorders)
  return _internal_debug_recorders();
}
inline void SourceInfo::_internal_set_debug_recorders(int32_t value) {
  
  _impl_.debug_recorders_ = value;
}
inline void SourceInfo::set_debug_recorders(int32_t value) {
  _internal_set_debug_recorders(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.debug_recorders)
}

// int32 sigmf_recorders = 20;
inline void SourceInfo::clear_sigmf_recorders() {
  _impl_.sigmf_recorders_ = 0;
}
inline int32_t SourceInfo::_internal_sigmf_recorders() const {
  return _impl_.sigmf_recorders_;
}
inline int32_t SourceInfo::sigmf_recorders() const {
  // @@protoc_insertion_point(field_get:streamer.SourceInfo.sigmf_recorders)
  return _internal_sigmf_recorders();
}
inline void SourceInfo::_internal_set_sigmf_recorders(int32_t value) {
  
  _impl_.sigmf_recorders_ = value;
}
inline void SourceInfo::set_sigmf_recorders(int32_t value) {
  _internal_set_sigmf_recorders(value);
  // @@protoc_insertion_point(field_set:streamer.SourceInfo.sigmf_recorders)
}

// -------------------------------------------------------------------

// SystemInfo

// int32 system_num = 1;
inline void SystemInfo::clear_system_num() {
  _impl_.system_num_ = 0;
}
inline int32_t SystemInfo::_internal_system_num() const {
  return _impl_.system_num_;
}
inline int32_t SystemInfo::system_num() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.system_num)
  return _internal_system_num();
}
inline void SystemInfo::_internal_set_system_num(int32_t value) {
  
  _impl_.system_num_ = value;
}
inline void SystemInfo::set_system_num(int32_t value) {
  _internal_set_system_num(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.system_num)
}

// string system_type = 2;
inline void SystemInfo::clear_system_type() {
  _impl_.system_type_.ClearToEmpty();
}
inline const std::string& SystemInfo::system_type() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.system_type)
  return _internal_system_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_system_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.system_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.system_type)
}
inline std::string* SystemInfo::mutable_system_type() {
  std::string* _s = _internal_mutable_system_type();
  // @@protoc_insertion_point(field_mutable:streamer.SystemInfo.system_type)
  return _s;
}
inline const std::string& SystemInfo::_internal_system_type() const {
  return _impl_.system_type_.Get();
}
inline void SystemInfo::_internal_set_system_type(const std::string& value) {
  
  _impl_.system_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_system_type() {
  
  return _impl_.system_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_system_type() {
  // @@protoc_insertion_point(field_release:streamer.SystemInfo.system_type)
  return _impl_.system_type_.Release();
}
inline void SystemInfo::set_allocated_system_type(std::string* system_type) {
  if (system_type != nullptr) {
    
  } else {
    
  }
  _impl_.system_type_.SetAllocated(system_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_type_.IsDefault()) {
    _impl_.system_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SystemInfo.system_type)
}

// string system_name = 3;
inline void SystemInfo::clear_system_name() {
  _impl_.system_name_.ClearToEmpty();
}
inline const std::string& SystemInfo::system_name() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.system_name)
  return _internal_system_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_system_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.system_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.system_name)
}
inline std::string* SystemInfo::mutable_system_name() {
  std::string* _s = _internal_mutable_system_name();
  // @@protoc_insertion_point(field_mutable:streamer.SystemInfo.system_name)
  return _s;
}
inline const std::string& SystemInfo::_internal_system_name() const {
  return _impl_.system_name_.Get();
}
inline void SystemInfo::_internal_set_system_name(const std::string& value) {
  
  _impl_.system_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_system_name() {
  
  return _impl_.system_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_system_name() {
  // @@protoc_insertion_point(field_release:streamer.SystemInfo.system_name)
  return _impl_.system_name_.Release();
}
inline void SystemInfo::set_allocated_system_name(std::string* system_name) {
  if (system_name != nullptr) {
    
  } else {
    
  }
  _impl_.system_name_.SetAllocated(system_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_name_.IsDefault()) {
    _impl_.system_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SystemInfo.system_name)
}

// bool audio_archive = 4;
inline void SystemInfo::clear_audio_archive() {
  _impl_.audio_archive_ = false;
}
inline bool SystemInfo::_internal_audio_archive() const {
  return _impl_.audio_archive_;
}
inline bool SystemInfo::audio_archive() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.audio_archive)
  return _internal_audio_archive();
}
inline void SystemInfo::_internal_set_audio_archive(bool value) {
  
  _impl_.audio_archive_ = value;
}
inline void SystemInfo::set_audio_archive(bool value) {
  _internal_set_audio_archive(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.audio_archive)
}

// bool record_unknown = 6;
inline void SystemInfo::clear_record_unknown() {
  _impl_.record_unknown_ = false;
}
inline bool SystemInfo::_internal_record_unknown() const {
  return _impl_.record_unknown_;
}
inline bool SystemInfo::record_unknown() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.record_unknown)
  return _internal_record_unknown();
}
inline void SystemInfo::_internal_set_record_unknown(bool value) {
  
  _impl_.record_unknown_ = value;
}
inline void SystemInfo::set_record_unknown(bool value) {
  _internal_set_record_unknown(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.record_unknown)
}

// bool call_log = 7;
inline void SystemInfo::clear_call_log() {
  _impl_.call_log_ = false;
}
inline bool SystemInfo::_internal_call_log() const {
  return _impl_.call_log_;
}
inline bool SystemInfo::call_log() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.call_log)
  return _internal_call_log();
}
inline void SystemInfo::_internal_set_call_log(bool value) {
  
  _impl_.call_log_ = value;
}
inline void SystemInfo::set_call_log(bool value) {
  _internal_set_call_log(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.call_log)
}

// string talkgroups_file = 8;
inline void SystemInfo::clear_talkgroups_file() {
  _impl_.talkgroups_file_.ClearToEmpty();
}
inline const std::string& SystemInfo::talkgroups_file() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.talkgroups_file)
  return _internal_talkgroups_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_talkgroups_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.talkgroups_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.talkgroups_file)
}
inline std::string* SystemInfo::mutable_talkgroups_file() {
  std::string* _s = _internal_mutable_talkgroups_file();
  // @@protoc_insertion_point(field_mutable:streamer.SystemInfo.talkgroups_file)
  return _s;
}
inline const std::string& SystemInfo::_internal_talkgroups_file() const {
  return _impl_.talkgroups_file_.Get();
}
inline void SystemInfo::_internal_set_talkgroups_file(const std::string& value) {
  
  _impl_.talkgroups_file_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_talkgroups_file() {
  
  return _impl_.talkgroups_file_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_talkgroups_file() {
  // @@protoc_insertion_point(field_release:streamer.SystemInfo.talkgroups_file)
  return _impl_.talkgroups_file_.Release();
}
inline void SystemInfo::set_allocated_talkgroups_file(std::string* talkgroups_file) {
  if (talkgroups_file != nullptr) {
    
  } else {
    
  }
  _impl_.talkgroups_file_.SetAllocated(talkgroups_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.talkgroups_file_.IsDefault()) {
    _impl_.talkgroups_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SystemInfo.talkgroups_file)
}

// double analog_levels = 9;
inline void SystemInfo::clear_analog_levels() {
  _impl_.analog_levels_ = 0;
}
inline double SystemInfo::_internal_analog_levels() const {
  return _impl_.analog_levels_;
}
inline double SystemInfo::analog_levels() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.analog_levels)
  return _internal_analog_levels();
}
inline void SystemInfo::_internal_set_analog_levels(double value) {
  
  _impl_.analog_levels_ = value;
}
inline void SystemInfo::set_analog_levels(double value) {
  _internal_set_analog_levels(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.analog_levels)
}

// double digital_levels = 10;
inline void SystemInfo::clear_digital_levels() {
  _impl_.digital_levels_ = 0;
}
inline double SystemInfo::_internal_digital_levels() const {
  return _impl_.digital_levels_;
}
inline double SystemInfo::digital_levels() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.digital_levels)
  return _internal_digital_levels();
}
inline void SystemInfo::_internal_set_digital_levels(double value) {
  
  _impl_.digital_levels_ = value;
}
inline void SystemInfo::set_digital_levels(double value) {
  _internal_set_digital_levels(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.digital_levels)
}

// bool qpsk = 11;
inline void SystemInfo::clear_qpsk() {
  _impl_.qpsk_ = false;
}
inline bool SystemInfo::_internal_qpsk() const {
  return _impl_.qpsk_;
}
inline bool SystemInfo::qpsk() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.qpsk)
  return _internal_qpsk();
}
inline void SystemInfo::_internal_set_qpsk(bool value) {
  
  _impl_.qpsk_ = value;
}
inline void SystemInfo::set_qpsk(bool value) {
  _internal_set_qpsk(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.qpsk)
}

// double squelch_db = 12;
inline void SystemInfo::clear_squelch_db() {
  _impl_.squelch_db_ = 0;
}
inline double SystemInfo::_internal_squelch_db() const {
  return _impl_.squelch_db_;
}
inline double SystemInfo::squelch_db() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.squelch_db)
  return _internal_squelch_db();
}
inline void SystemInfo::_internal_set_squelch_db(double value) {
  
  _impl_.squelch_db_ = value;
}
inline void SystemInfo::set_squelch_db(double value) {
  _internal_set_squelch_db(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.squelch_db)
}

// repeated double channels = 13;
inline int SystemInfo::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int SystemInfo::channels_size() const {
  return _internal_channels_size();
}
inline void SystemInfo::clear_channels() {
  _impl_.channels_.Clear();
}
inline double SystemInfo::_internal_channels(int index) const {
  return _impl_.channels_.Get(index);
}
inline double SystemInfo::channels(int index) const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.channels)
  return _internal_channels(index);
}
inline void SystemInfo::set_channels(int index, double value) {
  _impl_.channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.channels)
}
inline void SystemInfo::_internal_add_channels(double value) {
  _impl_.channels_.Add(value);
}
inline void SystemInfo::add_channels(double value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:streamer.SystemInfo.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SystemInfo::_internal_channels() const {
  return _impl_.channels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SystemInfo::channels() const {
  // @@protoc_insertion_point(field_list:streamer.SystemInfo.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SystemInfo::_internal_mutable_channels() {
  return &_impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SystemInfo::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:streamer.SystemInfo.channels)
  return _internal_mutable_channels();
}

// string bandplan = 14;
inline void SystemInfo::clear_bandplan() {
  _impl_.bandplan_.ClearToEmpty();
}
inline const std::string& SystemInfo::bandplan() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandplan)
  return _internal_bandplan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_bandplan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bandplan_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandplan)
}
inline std::string* SystemInfo::mutable_bandplan() {
  std::string* _s = _internal_mutable_bandplan();
  // @@protoc_insertion_point(field_mutable:streamer.SystemInfo.bandplan)
  return _s;
}
inline const std::string& SystemInfo::_internal_bandplan() const {
  return _impl_.bandplan_.Get();
}
inline void SystemInfo::_internal_set_bandplan(const std::string& value) {
  
  _impl_.bandplan_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_bandplan() {
  
  return _impl_.bandplan_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_bandplan() {
  // @@protoc_insertion_point(field_release:streamer.SystemInfo.bandplan)
  return _impl_.bandplan_.Release();
}
inline void SystemInfo::set_allocated_bandplan(std::string* bandplan) {
  if (bandplan != nullptr) {
    
  } else {
    
  }
  _impl_.bandplan_.SetAllocated(bandplan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bandplan_.IsDefault()) {
    _impl_.bandplan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SystemInfo.bandplan)
}

// int32 bandfreq = 15;
inline void SystemInfo::clear_bandfreq() {
  _impl_.bandfreq_ = 0;
}
inline int32_t SystemInfo::_internal_bandfreq() const {
  return _impl_.bandfreq_;
}
inline int32_t SystemInfo::bandfreq() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandfreq)
  return _internal_bandfreq();
}
inline void SystemInfo::_internal_set_bandfreq(int32_t value) {
  
  _impl_.bandfreq_ = value;
}
inline void SystemInfo::set_bandfreq(int32_t value) {
  _internal_set_bandfreq(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandfreq)
}

// double bandplan_base = 16;
inline void SystemInfo::clear_bandplan_base() {
  _impl_.bandplan_base_ = 0;
}
inline double SystemInfo::_internal_bandplan_base() const {
  return _impl_.bandplan_base_;
}
inline double SystemInfo::bandplan_base() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandplan_base)
  return _internal_bandplan_base();
}
inline void SystemInfo::_internal_set_bandplan_base(double value) {
  
  _impl_.bandplan_base_ = value;
}
inline void SystemInfo::set_bandplan_base(double value) {
  _internal_set_bandplan_base(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandplan_base)
}

// double bandplan_high = 17;
inline void SystemInfo::clear_bandplan_high() {
  _impl_.bandplan_high_ = 0;
}
inline double SystemInfo::_internal_bandplan_high() const {
  return _impl_.bandplan_high_;
}
inline double SystemInfo::bandplan_high() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandplan_high)
  return _internal_bandplan_high();
}
inline void SystemInfo::_internal_set_bandplan_high(double value) {
  
  _impl_.bandplan_high_ = value;
}
inline void SystemInfo::set_bandplan_high(double value) {
  _internal_set_bandplan_high(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandplan_high)
}

// double bandplan_spacing = 18;
inline void SystemInfo::clear_bandplan_spacing() {
  _impl_.bandplan_spacing_ = 0;
}
inline double SystemInfo::_internal_bandplan_spacing() const {
  return _impl_.bandplan_spacing_;
}
inline double SystemInfo::bandplan_spacing() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandplan_spacing)
  return _internal_bandplan_spacing();
}
inline void SystemInfo::_internal_set_bandplan_spacing(double value) {
  
  _impl_.bandplan_spacing_ = value;
}
inline void SystemInfo::set_bandplan_spacing(double value) {
  _internal_set_bandplan_spacing(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandplan_spacing)
}

// int32 bandplan_offset = 19;
inline void SystemInfo::clear_bandplan_offset() {
  _impl_.bandplan_offset_ = 0;
}
inline int32_t SystemInfo::_internal_bandplan_offset() const {
  return _impl_.bandplan_offset_;
}
inline int32_t SystemInfo::bandplan_offset() const {
  // @@protoc_insertion_point(field_get:streamer.SystemInfo.bandplan_offset)
  return _internal_bandplan_offset();
}
inline void SystemInfo::_internal_set_bandplan_offset(int32_t value) {
  
  _impl_.bandplan_offset_ = value;
}
inline void SystemInfo::set_bandplan_offset(int32_t value) {
  _internal_set_bandplan_offset(value);
  // @@protoc_insertion_point(field_set:streamer.SystemInfo.bandplan_offset)
}

// -------------------------------------------------------------------

// ConfigInfo

// repeated .streamer.SourceInfo sources = 1;
inline int ConfigInfo::_internal_sources_size() const {
  return _impl_.sources_.size();
}
inline int ConfigInfo::sources_size() const {
  return _internal_sources_size();
}
inline void ConfigInfo::clear_sources() {
  _impl_.sources_.Clear();
}
inline ::streamer::SourceInfo* ConfigInfo::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.sources)
  return _impl_.sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SourceInfo >*
ConfigInfo::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:streamer.ConfigInfo.sources)
  return &_impl_.sources_;
}
inline const ::streamer::SourceInfo& ConfigInfo::_internal_sources(int index) const {
  return _impl_.sources_.Get(index);
}
inline const ::streamer::SourceInfo& ConfigInfo::sources(int index) const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.sources)
  return _internal_sources(index);
}
inline ::streamer::SourceInfo* ConfigInfo::_internal_add_sources() {
  return _impl_.sources_.Add();
}
inline ::streamer::SourceInfo* ConfigInfo::add_sources() {
  ::streamer::SourceInfo* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:streamer.ConfigInfo.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SourceInfo >&
ConfigInfo::sources() const {
  // @@protoc_insertion_point(field_list:streamer.ConfigInfo.sources)
  return _impl_.sources_;
}

// repeated .streamer.SystemInfo systems = 2;
inline int ConfigInfo::_internal_systems_size() const {
  return _impl_.systems_.size();
}
inline int ConfigInfo::systems_size() const {
  return _internal_systems_size();
}
inline void ConfigInfo::clear_systems() {
  _impl_.systems_.Clear();
}
inline ::streamer::SystemInfo* ConfigInfo::mutable_systems(int index) {
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.systems)
  return _impl_.systems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SystemInfo >*
ConfigInfo::mutable_systems() {
  // @@protoc_insertion_point(field_mutable_list:streamer.ConfigInfo.systems)
  return &_impl_.systems_;
}
inline const ::streamer::SystemInfo& ConfigInfo::_internal_systems(int index) const {
  return _impl_.systems_.Get(index);
}
inline const ::streamer::SystemInfo& ConfigInfo::systems(int index) const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.systems)
  return _internal_systems(index);
}
inline ::streamer::SystemInfo* ConfigInfo::_internal_add_systems() {
  return _impl_.systems_.Add();
}
inline ::streamer::SystemInfo* ConfigInfo::add_systems() {
  ::streamer::SystemInfo* _add = _internal_add_systems();
  // @@protoc_insertion_point(field_add:streamer.ConfigInfo.systems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::streamer::SystemInfo >&
ConfigInfo::systems() const {
  // @@protoc_insertion_point(field_list:streamer.ConfigInfo.systems)
  return _impl_.systems_;
}

// string capture_dir = 3;
inline void ConfigInfo::clear_capture_dir() {
  _impl_.capture_dir_.ClearToEmpty();
}
inline const std::string& ConfigInfo::capture_dir() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.capture_dir)
  return _internal_capture_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigInfo::set_capture_dir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.capture_dir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.capture_dir)
}
inline std::string* ConfigInfo::mutable_capture_dir() {
  std::string* _s = _internal_mutable_capture_dir();
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.capture_dir)
  return _s;
}
inline const std::string& ConfigInfo::_internal_capture_dir() const {
  return _impl_.capture_dir_.Get();
}
inline void ConfigInfo::_internal_set_capture_dir(const std::string& value) {
  
  _impl_.capture_dir_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigInfo::_internal_mutable_capture_dir() {
  
  return _impl_.capture_dir_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigInfo::release_capture_dir() {
  // @@protoc_insertion_point(field_release:streamer.ConfigInfo.capture_dir)
  return _impl_.capture_dir_.Release();
}
inline void ConfigInfo::set_allocated_capture_dir(std::string* capture_dir) {
  if (capture_dir != nullptr) {
    
  } else {
    
  }
  _impl_.capture_dir_.SetAllocated(capture_dir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.capture_dir_.IsDefault()) {
    _impl_.capture_dir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.ConfigInfo.capture_dir)
}

// string upload_server = 4;
inline void ConfigInfo::clear_upload_server() {
  _impl_.upload_server_.ClearToEmpty();
}
inline const std::string& ConfigInfo::upload_server() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.upload_server)
  return _internal_upload_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigInfo::set_upload_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.upload_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.upload_server)
}
inline std::string* ConfigInfo::mutable_upload_server() {
  std::string* _s = _internal_mutable_upload_server();
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.upload_server)
  return _s;
}
inline const std::string& ConfigInfo::_internal_upload_server() const {
  return _impl_.upload_server_.Get();
}
inline void ConfigInfo::_internal_set_upload_server(const std::string& value) {
  
  _impl_.upload_server_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigInfo::_internal_mutable_upload_server() {
  
  return _impl_.upload_server_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigInfo::release_upload_server() {
  // @@protoc_insertion_point(field_release:streamer.ConfigInfo.upload_server)
  return _impl_.upload_server_.Release();
}
inline void ConfigInfo::set_allocated_upload_server(std::string* upload_server) {
  if (upload_server != nullptr) {
    
  } else {
    
  }
  _impl_.upload_server_.SetAllocated(upload_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.upload_server_.IsDefault()) {
    _impl_.upload_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.ConfigInfo.upload_server)
}

// int32 call_timeout = 5;
inline void ConfigInfo::clear_call_timeout() {
  _impl_.call_timeout_ = 0;
}
inline int32_t ConfigInfo::_internal_call_timeout() const {
  return _impl_.call_timeout_;
}
inline int32_t ConfigInfo::call_timeout() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.call_timeout)
  return _internal_call_timeout();
}
inline void ConfigInfo::_internal_set_call_timeout(int32_t value) {
  
  _impl_.call_timeout_ = value;
}
inline void ConfigInfo::set_call_timeout(int32_t value) {
  _internal_set_call_timeout(value);
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.call_timeout)
}

// bool log_file = 6;
inline void ConfigInfo::clear_log_file() {
  _impl_.log_file_ = false;
}
inline bool ConfigInfo::_internal_log_file() const {
  return _impl_.log_file_;
}
inline bool ConfigInfo::log_file() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.log_file)
  return _internal_log_file();
}
inline void ConfigInfo::_internal_set_log_file(bool value) {
  
  _impl_.log_file_ = value;
}
inline void ConfigInfo::set_log_file(bool value) {
  _internal_set_log_file(value);
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.log_file)
}

// string instance_id = 7;
inline void ConfigInfo::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
}
inline const std::string& ConfigInfo::instance_id() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigInfo::set_instance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.instance_id)
}
inline std::string* ConfigInfo::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.instance_id)
  return _s;
}
inline const std::string& ConfigInfo::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void ConfigInfo::_internal_set_instance_id(const std::string& value) {
  
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigInfo::_internal_mutable_instance_id() {
  
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigInfo::release_instance_id() {
  // @@protoc_insertion_point(field_release:streamer.ConfigInfo.instance_id)
  return _impl_.instance_id_.Release();
}
inline void ConfigInfo::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    
  } else {
    
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.ConfigInfo.instance_id)
}

// string instance_key = 8;
inline void ConfigInfo::clear_instance_key() {
  _impl_.instance_key_.ClearToEmpty();
}
inline const std::string& ConfigInfo::instance_key() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.instance_key)
  return _internal_instance_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigInfo::set_instance_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.instance_key)
}
inline std::string* ConfigInfo::mutable_instance_key() {
  std::string* _s = _internal_mutable_instance_key();
  // @@protoc_insertion_point(field_mutable:streamer.ConfigInfo.instance_key)
  return _s;
}
inline const std::string& ConfigInfo::_internal_instance_key() const {
  return _impl_.instance_key_.Get();
}
inline void ConfigInfo::_internal_set_instance_key(const std::string& value) {
  
  _impl_.instance_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigInfo::_internal_mutable_instance_key() {
  
  return _impl_.instance_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigInfo::release_instance_key() {
  // @@protoc_insertion_point(field_release:streamer.ConfigInfo.instance_key)
  return _impl_.instance_key_.Release();
}
inline void ConfigInfo::set_allocated_instance_key(std::string* instance_key) {
  if (instance_key != nullptr) {
    
  } else {
    
  }
  _impl_.instance_key_.SetAllocated(instance_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_key_.IsDefault()) {
    _impl_.instance_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.ConfigInfo.instance_key)
}

// bool broadcast_signals = 9;
inline void ConfigInfo::clear_broadcast_signals() {
  _impl_.broadcast_signals_ = false;
}
inline bool ConfigInfo::_internal_broadcast_signals() const {
  return _impl_.broadcast_signals_;
}
inline bool ConfigInfo::broadcast_signals() const {
  // @@protoc_insertion_point(field_get:streamer.ConfigInfo.broadcast_signals)
  return _internal_broadcast_signals();
}
inline void ConfigInfo::_internal_set_broadcast_signals(bool value) {
  
  _impl_.broadcast_signals_ = value;
}
inline void ConfigInfo::set_broadcast_signals(bool value) {
  _internal_set_broadcast_signals(value);
  // @@protoc_insertion_point(field_set:streamer.ConfigInfo.broadcast_signals)
}

// -------------------------------------------------------------------

// CallInfo

// bool call_active = 1;
inline void CallInfo::clear_call_active() {
  _impl_.call_active_ = false;
}
inline bool CallInfo::_internal_call_active() const {
  return _impl_.call_active_;
}
inline bool CallInfo::call_active() const {
  // @@protoc_insertion_point(field_get:streamer.CallInfo.call_active)
  return _internal_call_active();
}
inline void CallInfo::_internal_set_call_active(bool value) {
  
  _impl_.call_active_ = value;
}
inline void CallInfo::set_call_active(bool value) {
  _internal_set_call_active(value);
  // @@protoc_insertion_point(field_set:streamer.CallInfo.call_active)
}

// int32 recorder_num = 2;
inline void CallInfo::clear_recorder_num() {
  _impl_.recorder_num_ = 0;
}
inline int32_t CallInfo::_internal_recorder_num() const {
  return _impl_.recorder_num_;
}
inline int32_t CallInfo::recorder_num() const {
  // @@protoc_insertion_point(field_get:streamer.CallInfo.recorder_num)
  return _internal_recorder_num();
}
inline void CallInfo::_internal_set_recorder_num(int32_t value) {
  
  _impl_.recorder_num_ = value;
}
inline void CallInfo::set_recorder_num(int32_t value) {
  _internal_set_recorder_num(value);
  // @@protoc_insertion_point(field_set:streamer.CallInfo.recorder_num)
}

// int32 system_num = 3;
inline void CallInfo::clear_system_num() {
  _impl_.system_num_ = 0;
}
inline int32_t CallInfo::_internal_system_num() const {
  return _impl_.system_num_;
}
inline int32_t CallInfo::system_num() const {
  // @@protoc_insertion_point(field_get:streamer.CallInfo.system_num)
  return _internal_system_num();
}
inline void CallInfo::_internal_set_system_num(int32_t value) {
  
  _impl_.system_num_ = value;
}
inline void CallInfo::set_system_num(int32_t value) {
  _internal_set_system_num(value);
  // @@protoc_insertion_point(field_set:streamer.CallInfo.system_num)
}

// double curr_freq = 4;
inline void CallInfo::clear_curr_freq() {
  _impl_.curr_freq_ = 0;
}
inline double CallInfo::_internal_curr_freq() const {
  return _impl_.curr_freq_;
}
inline double CallInfo::curr_freq() const {
  // @@protoc_insertion_point(field_get:streamer.CallInfo.curr_freq)
  return _internal_curr_freq();
}
inline void CallInfo::_internal_set_curr_freq(double value) {
  
  _impl_.curr_freq_ = value;
}
inline void CallInfo::set_curr_freq(double value) {
  _internal_set_curr_freq(value);
  // @@protoc_insertion_point(field_set:streamer.CallInfo.curr_freq)
}

// -------------------------------------------------------------------

// SignalInfo

// int64 unit_id = 1;
inline void SignalInfo::clear_unit_id() {
  _impl_.unit_id_ = int64_t{0};
}
inline int64_t SignalInfo::_internal_unit_id() const {
  return _impl_.unit_id_;
}
inline int64_t SignalInfo::unit_id() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.unit_id)
  return _internal_unit_id();
}
inline void SignalInfo::_internal_set_unit_id(int64_t value) {
  
  _impl_.unit_id_ = value;
}
inline void SignalInfo::set_unit_id(int64_t value) {
  _internal_set_unit_id(value);
  // @@protoc_insertion_point(field_set:streamer.SignalInfo.unit_id)
}

// string signaling_type = 2;
inline void SignalInfo::clear_signaling_type() {
  _impl_.signaling_type_.ClearToEmpty();
}
inline const std::string& SignalInfo::signaling_type() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.signaling_type)
  return _internal_signaling_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignalInfo::set_signaling_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signaling_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:streamer.SignalInfo.signaling_type)
}
inline std::string* SignalInfo::mutable_signaling_type() {
  std::string* _s = _internal_mutable_signaling_type();
  // @@protoc_insertion_point(field_mutable:streamer.SignalInfo.signaling_type)
  return _s;
}
inline const std::string& SignalInfo::_internal_signaling_type() const {
  return _impl_.signaling_type_.Get();
}
inline void SignalInfo::_internal_set_signaling_type(const std::string& value) {
  
  _impl_.signaling_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalInfo::_internal_mutable_signaling_type() {
  
  return _impl_.signaling_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalInfo::release_signaling_type() {
  // @@protoc_insertion_point(field_release:streamer.SignalInfo.signaling_type)
  return _impl_.signaling_type_.Release();
}
inline void SignalInfo::set_allocated_signaling_type(std::string* signaling_type) {
  if (signaling_type != nullptr) {
    
  } else {
    
  }
  _impl_.signaling_type_.SetAllocated(signaling_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signaling_type_.IsDefault()) {
    _impl_.signaling_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:streamer.SignalInfo.signaling_type)
}

// .streamer.SignalInfo.SignalType signal_type = 3;
inline void SignalInfo::clear_signal_type() {
  _impl_.signal_type_ = 0;
}
inline ::streamer::SignalInfo_SignalType SignalInfo::_internal_signal_type() const {
  return static_cast< ::streamer::SignalInfo_SignalType >(_impl_.signal_type_);
}
inline ::streamer::SignalInfo_SignalType SignalInfo::signal_type() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.signal_type)
  return _internal_signal_type();
}
inline void SignalInfo::_internal_set_signal_type(::streamer::SignalInfo_SignalType value) {
  
  _impl_.signal_type_ = value;
}
inline void SignalInfo::set_signal_type(::streamer::SignalInfo_SignalType value) {
  _internal_set_signal_type(value);
  // @@protoc_insertion_point(field_set:streamer.SignalInfo.signal_type)
}

// .streamer.CallInfo call_info = 4;
inline bool SignalInfo::_internal_has_call_info() const {
  return this != internal_default_instance() && _impl_.call_info_ != nullptr;
}
inline bool SignalInfo::has_call_info() const {
  return _internal_has_call_info();
}
inline void SignalInfo::clear_call_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.call_info_ != nullptr) {
    delete _impl_.call_info_;
  }
  _impl_.call_info_ = nullptr;
}
inline const ::streamer::CallInfo& SignalInfo::_internal_call_info() const {
  const ::streamer::CallInfo* p = _impl_.call_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::streamer::CallInfo&>(
      ::streamer::_CallInfo_default_instance_);
}
inline const ::streamer::CallInfo& SignalInfo::call_info() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.call_info)
  return _internal_call_info();
}
inline void SignalInfo::unsafe_arena_set_allocated_call_info(
    ::streamer::CallInfo* call_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.call_info_);
  }
  _impl_.call_info_ = call_info;
  if (call_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:streamer.SignalInfo.call_info)
}
inline ::streamer::CallInfo* SignalInfo::release_call_info() {
  
  ::streamer::CallInfo* temp = _impl_.call_info_;
  _impl_.call_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::streamer::CallInfo* SignalInfo::unsafe_arena_release_call_info() {
  // @@protoc_insertion_point(field_release:streamer.SignalInfo.call_info)
  
  ::streamer::CallInfo* temp = _impl_.call_info_;
  _impl_.call_info_ = nullptr;
  return temp;
}
inline ::streamer::CallInfo* SignalInfo::_internal_mutable_call_info() {
  
  if (_impl_.call_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::streamer::CallInfo>(GetArenaForAllocation());
    _impl_.call_info_ = p;
  }
  return _impl_.call_info_;
}
inline ::streamer::CallInfo* SignalInfo::mutable_call_info() {
  ::streamer::CallInfo* _msg = _internal_mutable_call_info();
  // @@protoc_insertion_point(field_mutable:streamer.SignalInfo.call_info)
  return _msg;
}
inline void SignalInfo::set_allocated_call_info(::streamer::CallInfo* call_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.call_info_;
  }
  if (call_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(call_info);
    if (message_arena != submessage_arena) {
      call_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.call_info_ = call_info;
  // @@protoc_insertion_point(field_set_allocated:streamer.SignalInfo.call_info)
}

// .streamer.SystemInfo system_info = 5;
inline bool SignalInfo::_internal_has_system_info() const {
  return this != internal_default_instance() && _impl_.system_info_ != nullptr;
}
inline bool SignalInfo::has_system_info() const {
  return _internal_has_system_info();
}
inline void SignalInfo::clear_system_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.system_info_ != nullptr) {
    delete _impl_.system_info_;
  }
  _impl_.system_info_ = nullptr;
}
inline const ::streamer::SystemInfo& SignalInfo::_internal_system_info() const {
  const ::streamer::SystemInfo* p = _impl_.system_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::streamer::SystemInfo&>(
      ::streamer::_SystemInfo_default_instance_);
}
inline const ::streamer::SystemInfo& SignalInfo::system_info() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.system_info)
  return _internal_system_info();
}
inline void SignalInfo::unsafe_arena_set_allocated_system_info(
    ::streamer::SystemInfo* system_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_info_);
  }
  _impl_.system_info_ = system_info;
  if (system_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:streamer.SignalInfo.system_info)
}
inline ::streamer::SystemInfo* SignalInfo::release_system_info() {
  
  ::streamer::SystemInfo* temp = _impl_.system_info_;
  _impl_.system_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::streamer::SystemInfo* SignalInfo::unsafe_arena_release_system_info() {
  // @@protoc_insertion_point(field_release:streamer.SignalInfo.system_info)
  
  ::streamer::SystemInfo* temp = _impl_.system_info_;
  _impl_.system_info_ = nullptr;
  return temp;
}
inline ::streamer::SystemInfo* SignalInfo::_internal_mutable_system_info() {
  
  if (_impl_.system_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::streamer::SystemInfo>(GetArenaForAllocation());
    _impl_.system_info_ = p;
  }
  return _impl_.system_info_;
}
inline ::streamer::SystemInfo* SignalInfo::mutable_system_info() {
  ::streamer::SystemInfo* _msg = _internal_mutable_system_info();
  // @@protoc_insertion_point(field_mutable:streamer.SignalInfo.system_info)
  return _msg;
}
inline void SignalInfo::set_allocated_system_info(::streamer::SystemInfo* system_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_info_;
  }
  if (system_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_info);
    if (message_arena != submessage_arena) {
      system_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.system_info_ = system_info;
  // @@protoc_insertion_point(field_set_allocated:streamer.SignalInfo.system_info)
}

// .streamer.RecorderInfo recorder_info = 6;
inline bool SignalInfo::_internal_has_recorder_info() const {
  return this != internal_default_instance() && _impl_.recorder_info_ != nullptr;
}
inline bool SignalInfo::has_recorder_info() const {
  return _internal_has_recorder_info();
}
inline void SignalInfo::clear_recorder_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.recorder_info_ != nullptr) {
    delete _impl_.recorder_info_;
  }
  _impl_.recorder_info_ = nullptr;
}
inline const ::streamer::RecorderInfo& SignalInfo::_internal_recorder_info() const {
  const ::streamer::RecorderInfo* p = _impl_.recorder_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::streamer::RecorderInfo&>(
      ::streamer::_RecorderInfo_default_instance_);
}
inline const ::streamer::RecorderInfo& SignalInfo::recorder_info() const {
  // @@protoc_insertion_point(field_get:streamer.SignalInfo.recorder_info)
  return _internal_recorder_info();
}
inline void SignalInfo::unsafe_arena_set_allocated_recorder_info(
    ::streamer::RecorderInfo* recorder_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recorder_info_);
  }
  _impl_.recorder_info_ = recorder_info;
  if (recorder_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:streamer.SignalInfo.recorder_info)
}
inline ::streamer::RecorderInfo* SignalInfo::release_recorder_info() {
  
  ::streamer::RecorderInfo* temp = _impl_.recorder_info_;
  _impl_.recorder_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::streamer::RecorderInfo* SignalInfo::unsafe_arena_release_recorder_info() {
  // @@protoc_insertion_point(field_release:streamer.SignalInfo.recorder_info)
  
  ::streamer::RecorderInfo* temp = _impl_.recorder_info_;
  _impl_.recorder_info_ = nullptr;
  return temp;
}
inline ::streamer::RecorderInfo* SignalInfo::_internal_mutable_recorder_info() {
  
  if (_impl_.recorder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::streamer::RecorderInfo>(GetArenaForAllocation());
    _impl_.recorder_info_ = p;
  }
  return _impl_.recorder_info_;
}
inline ::streamer::RecorderInfo* SignalInfo::mutable_recorder_info() {
  ::streamer::RecorderInfo* _msg = _internal_mutable_recorder_info();
  // @@protoc_insertion_point(field_mutable:streamer.SignalInfo.recorder_info)
  return _msg;
}
inline void SignalInfo::set_allocated_recorder_info(::streamer::RecorderInfo* recorder_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recorder_info_;
  }
  if (recorder_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recorder_info);
    if (message_arena != submessage_arena) {
      recorder_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recorder_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recorder_info_ = recorder_info;
  // @@protoc_insertion_point(field_set_allocated:streamer.SignalInfo.recorder_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace streamer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::streamer::RecorderInfo_RecorderState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::streamer::RecorderInfo_RecorderState>() {
  return ::streamer::RecorderInfo_RecorderState_descriptor();
}
template <> struct is_proto_enum< ::streamer::RecorderInfo_AudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::streamer::RecorderInfo_AudioFormat>() {
  return ::streamer::RecorderInfo_AudioFormat_descriptor();
}
template <> struct is_proto_enum< ::streamer::SignalInfo_SignalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::streamer::SignalInfo_SignalType>() {
  return ::streamer::SignalInfo_SignalType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_streamer_2eproto
