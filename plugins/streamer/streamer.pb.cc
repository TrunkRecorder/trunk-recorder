// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: streamer.proto

#include "streamer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace streamer {
PROTOBUF_CONSTEXPR AudioSample::AudioSample(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sample_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recorder_num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioSampleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioSampleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioSampleDefaultTypeInternal() {}
  union {
    AudioSample _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioSampleDefaultTypeInternal _AudioSample_default_instance_;
PROTOBUF_CONSTEXPR RecorderInfo::RecorderInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recorder_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recorder_num_)*/0
  , /*decltype(_impl_.source_num_)*/0
  , /*decltype(_impl_.recorder_duration_)*/0
  , /*decltype(_impl_.recorder_count_)*/0
  , /*decltype(_impl_.recorder_state_)*/0
  , /*decltype(_impl_.status_len_)*/0
  , /*decltype(_impl_.status_error_)*/0
  , /*decltype(_impl_.status_spike_)*/0
  , /*decltype(_impl_.audio_sample_rate_)*/0
  , /*decltype(_impl_.audio_channels_)*/0
  , /*decltype(_impl_.audio_format_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecorderInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecorderInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecorderInfoDefaultTypeInternal() {}
  union {
    RecorderInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecorderInfoDefaultTypeInternal _RecorderInfo_default_instance_;
PROTOBUF_CONSTEXPR SourceInfo::SourceInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.driver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.antenna_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.min_hz_)*/0
  , /*decltype(_impl_.max_hz_)*/0
  , /*decltype(_impl_.center_hz_)*/0
  , /*decltype(_impl_.rate_)*/0
  , /*decltype(_impl_.source_num_)*/0
  , /*decltype(_impl_.mix_gain_)*/0
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.lna_gain_)*/0
  , /*decltype(_impl_.vga1_gain_)*/0
  , /*decltype(_impl_.vga2_gain_)*/0
  , /*decltype(_impl_.bb_gain_)*/0
  , /*decltype(_impl_.gain_)*/0
  , /*decltype(_impl_.if_gain_)*/0
  , /*decltype(_impl_.analog_recorders_)*/0
  , /*decltype(_impl_.digital_recorders_)*/0
  , /*decltype(_impl_.debug_recorders_)*/0
  , /*decltype(_impl_.sigmf_recorders_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SourceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SourceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SourceInfoDefaultTypeInternal() {}
  union {
    SourceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SourceInfoDefaultTypeInternal _SourceInfo_default_instance_;
PROTOBUF_CONSTEXPR SystemInfo::SystemInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.channels_)*/{}
  , /*decltype(_impl_.system_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.talkgroups_file_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bandplan_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.system_num_)*/0
  , /*decltype(_impl_.audio_archive_)*/false
  , /*decltype(_impl_.record_unknown_)*/false
  , /*decltype(_impl_.call_log_)*/false
  , /*decltype(_impl_.qpsk_)*/false
  , /*decltype(_impl_.analog_levels_)*/0
  , /*decltype(_impl_.digital_levels_)*/0
  , /*decltype(_impl_.squelch_db_)*/0
  , /*decltype(_impl_.bandplan_base_)*/0
  , /*decltype(_impl_.bandplan_high_)*/0
  , /*decltype(_impl_.bandfreq_)*/0
  , /*decltype(_impl_.bandplan_offset_)*/0
  , /*decltype(_impl_.bandplan_spacing_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemInfoDefaultTypeInternal() {}
  union {
    SystemInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
PROTOBUF_CONSTEXPR ConfigInfo::ConfigInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sources_)*/{}
  , /*decltype(_impl_.systems_)*/{}
  , /*decltype(_impl_.capture_dir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.upload_server_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.call_timeout_)*/0
  , /*decltype(_impl_.log_file_)*/false
  , /*decltype(_impl_.broadcast_signals_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConfigInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigInfoDefaultTypeInternal() {}
  union {
    ConfigInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigInfoDefaultTypeInternal _ConfigInfo_default_instance_;
PROTOBUF_CONSTEXPR CallInfo::CallInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.call_active_)*/false
  , /*decltype(_impl_.recorder_num_)*/0
  , /*decltype(_impl_.curr_freq_)*/0
  , /*decltype(_impl_.system_num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CallInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallInfoDefaultTypeInternal() {}
  union {
    CallInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallInfoDefaultTypeInternal _CallInfo_default_instance_;
PROTOBUF_CONSTEXPR SignalInfo::SignalInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signaling_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.call_info_)*/nullptr
  , /*decltype(_impl_.system_info_)*/nullptr
  , /*decltype(_impl_.recorder_info_)*/nullptr
  , /*decltype(_impl_.unit_id_)*/int64_t{0}
  , /*decltype(_impl_.signal_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignalInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalInfoDefaultTypeInternal() {}
  union {
    SignalInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalInfoDefaultTypeInternal _SignalInfo_default_instance_;
}  // namespace streamer
static ::_pb::Metadata file_level_metadata_streamer_2eproto[7];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_streamer_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_streamer_2eproto = nullptr;

const uint32_t TableStruct_streamer_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::AudioSample, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::AudioSample, _impl_.recorder_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::AudioSample, _impl_.sample_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.recorder_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.recorder_type_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.source_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.recorder_count_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.recorder_duration_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.recorder_state_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.status_len_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.status_error_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.status_spike_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.audio_sample_rate_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.audio_channels_),
  PROTOBUF_FIELD_OFFSET(::streamer::RecorderInfo, _impl_.audio_format_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.source_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.min_hz_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.max_hz_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.center_hz_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.rate_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.driver_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.device_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.antenna_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.mix_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.lna_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.vga1_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.vga2_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.bb_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.if_gain_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.analog_recorders_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.digital_recorders_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.debug_recorders_),
  PROTOBUF_FIELD_OFFSET(::streamer::SourceInfo, _impl_.sigmf_recorders_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.system_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.system_type_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.system_name_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.audio_archive_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.record_unknown_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.call_log_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.talkgroups_file_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.analog_levels_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.digital_levels_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.qpsk_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.squelch_db_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.channels_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandplan_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandfreq_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandplan_base_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandplan_high_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandplan_spacing_),
  PROTOBUF_FIELD_OFFSET(::streamer::SystemInfo, _impl_.bandplan_offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.sources_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.systems_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.capture_dir_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.upload_server_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.call_timeout_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.log_file_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.instance_id_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.instance_key_),
  PROTOBUF_FIELD_OFFSET(::streamer::ConfigInfo, _impl_.broadcast_signals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::CallInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::CallInfo, _impl_.call_active_),
  PROTOBUF_FIELD_OFFSET(::streamer::CallInfo, _impl_.recorder_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::CallInfo, _impl_.system_num_),
  PROTOBUF_FIELD_OFFSET(::streamer::CallInfo, _impl_.curr_freq_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.unit_id_),
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.signaling_type_),
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.signal_type_),
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.call_info_),
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.system_info_),
  PROTOBUF_FIELD_OFFSET(::streamer::SignalInfo, _impl_.recorder_info_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::streamer::AudioSample)},
  { 8, -1, -1, sizeof(::streamer::RecorderInfo)},
  { 27, -1, -1, sizeof(::streamer::SourceInfo)},
  { 53, -1, -1, sizeof(::streamer::SystemInfo)},
  { 77, -1, -1, sizeof(::streamer::ConfigInfo)},
  { 92, -1, -1, sizeof(::streamer::CallInfo)},
  { 102, -1, -1, sizeof(::streamer::SignalInfo)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::streamer::_AudioSample_default_instance_._instance,
  &::streamer::_RecorderInfo_default_instance_._instance,
  &::streamer::_SourceInfo_default_instance_._instance,
  &::streamer::_SystemInfo_default_instance_._instance,
  &::streamer::_ConfigInfo_default_instance_._instance,
  &::streamer::_CallInfo_default_instance_._instance,
  &::streamer::_SignalInfo_default_instance_._instance,
};

const char descriptor_table_protodef_streamer_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016streamer.proto\022\010streamer\032\033google/proto"
  "buf/empty.proto\"3\n\013AudioSample\022\024\n\014record"
  "er_num\030\001 \001(\005\022\016\n\006sample\030\002 \001(\014\"\230\004\n\014Recorde"
  "rInfo\022\024\n\014recorder_num\030\001 \001(\005\022\025\n\rrecorder_"
  "type\030\002 \001(\t\022\022\n\nsource_num\030\003 \001(\005\022\n\n\002id\030\004 \001"
  "(\t\022\026\n\016recorder_count\030\005 \001(\005\022\031\n\021recorder_d"
  "uration\030\006 \001(\001\022<\n\016recorder_state\030\007 \001(\0162$."
  "streamer.RecorderInfo.RecorderState\022\022\n\ns"
  "tatus_len\030\010 \001(\001\022\024\n\014status_error\030\t \001(\001\022\024\n"
  "\014status_spike\030\n \001(\001\022\031\n\021audio_sample_rate"
  "\030\013 \001(\005\022\026\n\016audio_channels\030\014 \001(\005\0228\n\014audio_"
  "format\030\r \001(\0162\".streamer.RecorderInfo.Aud"
  "ioFormat\"H\n\rRecorderState\022\016\n\nMonitoring\020"
  "\000\022\r\n\tRecording\020\001\022\014\n\010Inactive\020\002\022\n\n\006Active"
  "\020\003\"S\n\013AudioFormat\022\013\n\007Float32\020\000\022\014\n\010Signed"
  "16\020\001\022\014\n\010Signed24\020\002\022\014\n\010Signed32\020\003\022\r\n\tUnsi"
  "gned8\020\004\"\202\003\n\nSourceInfo\022\022\n\nsource_num\030\001 \001"
  "(\005\022\016\n\006min_hz\030\002 \001(\001\022\016\n\006max_hz\030\003 \001(\001\022\021\n\tce"
  "nter_hz\030\004 \001(\001\022\014\n\004rate\030\005 \001(\001\022\016\n\006driver\030\006 "
  "\001(\t\022\016\n\006device\030\007 \001(\t\022\017\n\007antenna\030\010 \001(\t\022\r\n\005"
  "error\030\t \001(\001\022\020\n\010mix_gain\030\n \001(\005\022\020\n\010lna_gai"
  "n\030\013 \001(\005\022\021\n\tvga1_gain\030\014 \001(\005\022\021\n\tvga2_gain\030"
  "\r \001(\005\022\017\n\007bb_gain\030\016 \001(\005\022\014\n\004gain\030\017 \001(\005\022\017\n\007"
  "if_gain\030\020 \001(\005\022\030\n\020analog_recorders\030\021 \001(\005\022"
  "\031\n\021digital_recorders\030\022 \001(\005\022\027\n\017debug_reco"
  "rders\030\023 \001(\005\022\027\n\017sigmf_recorders\030\024 \001(\005\"\241\003\n"
  "\nSystemInfo\022\022\n\nsystem_num\030\001 \001(\005\022\023\n\013syste"
  "m_type\030\002 \001(\t\022\023\n\013system_name\030\003 \001(\t\022\025\n\raud"
  "io_archive\030\004 \001(\010\022\026\n\016record_unknown\030\006 \001(\010"
  "\022\020\n\010call_log\030\007 \001(\010\022\027\n\017talkgroups_file\030\010 "
  "\001(\t\022\025\n\ranalog_levels\030\t \001(\001\022\026\n\016digital_le"
  "vels\030\n \001(\001\022\014\n\004qpsk\030\013 \001(\010\022\022\n\nsquelch_db\030\014"
  " \001(\001\022\020\n\010channels\030\r \003(\001\022\020\n\010bandplan\030\016 \001(\t"
  "\022\020\n\010bandfreq\030\017 \001(\005\022\025\n\rbandplan_base\030\020 \001("
  "\001\022\025\n\rbandplan_high\030\021 \001(\001\022\030\n\020bandplan_spa"
  "cing\030\022 \001(\001\022\027\n\017bandplan_offset\030\023 \001(\005J\004\010\005\020"
  "\006R\rupload_script\"\364\001\n\nConfigInfo\022%\n\007sourc"
  "es\030\001 \003(\0132\024.streamer.SourceInfo\022%\n\007system"
  "s\030\002 \003(\0132\024.streamer.SystemInfo\022\023\n\013capture"
  "_dir\030\003 \001(\t\022\025\n\rupload_server\030\004 \001(\t\022\024\n\014cal"
  "l_timeout\030\005 \001(\005\022\020\n\010log_file\030\006 \001(\010\022\023\n\013ins"
  "tance_id\030\007 \001(\t\022\024\n\014instance_key\030\010 \001(\t\022\031\n\021"
  "broadcast_signals\030\t \001(\010\"\\\n\010CallInfo\022\023\n\013c"
  "all_active\030\001 \001(\010\022\024\n\014recorder_num\030\002 \001(\005\022\022"
  "\n\nsystem_num\030\003 \001(\005\022\021\n\tcurr_freq\030\004 \001(\001\"\262\003"
  "\n\nSignalInfo\022\017\n\007unit_id\030\001 \001(\003\022\026\n\016signali"
  "ng_type\030\002 \001(\t\0224\n\013signal_type\030\003 \001(\0162\037.str"
  "eamer.SignalInfo.SignalType\022%\n\tcall_info"
  "\030\004 \001(\0132\022.streamer.CallInfo\022)\n\013system_inf"
  "o\030\005 \001(\0132\024.streamer.SystemInfo\022-\n\rrecorde"
  "r_info\030\006 \001(\0132\026.streamer.RecorderInfo\"\303\001\n"
  "\nSignalType\022\n\n\006Normal\020\000\022\r\n\tEmergency\020\001\022\020"
  "\n\014EmergencyAck\020\002\022\016\n\nRadioCheck\020\003\022\021\n\rRadi"
  "oCheckAck\020\004\022\r\n\tRadioStun\020\005\022\020\n\014RadioStunA"
  "ck\020\006\022\017\n\013RadioRevive\020\007\022\022\n\016RadioReviveAck\020"
  "\010\022\r\n\tNormalPre\020\t\022\020\n\014EmergencyPre\020\n2\200\004\n\025T"
  "runkRecorderStreamer\022=\n\nSendStream\022\025.str"
  "eamer.AudioSample\032\026.google.protobuf.Empt"
  "y(\001\022<\n\nSendSignal\022\024.streamer.SignalInfo\032"
  "\026.google.protobuf.Empty(\001\0229\n\013CallStarted"
  "\022\022.streamer.CallInfo\032\026.google.protobuf.E"
  "mpty\0227\n\tCallEnded\022\022.streamer.CallInfo\032\026."
  "google.protobuf.Empty\022\?\n\rSetupRecorder\022\026"
  ".streamer.RecorderInfo\032\026.google.protobuf"
  ".Empty\022;\n\013SetupSystem\022\024.streamer.SystemI"
  "nfo\032\026.google.protobuf.Empty\022;\n\013SetupSour"
  "ce\022\024.streamer.SourceInfo\032\026.google.protob"
  "uf.Empty\022;\n\013SetupConfig\022\024.streamer.Confi"
  "gInfo\032\026.google.protobuf.EmptyB=\n\032io.trun"
  "k.recorder.streamerP\001\242\002\003TRS\252\002\026TrunkRecor"
  "der.Streamerb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_streamer_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
};
static ::_pbi::once_flag descriptor_table_streamer_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_streamer_2eproto = {
    false, false, 2820, descriptor_table_protodef_streamer_2eproto,
    "streamer.proto",
    &descriptor_table_streamer_2eproto_once, descriptor_table_streamer_2eproto_deps, 1, 7,
    schemas, file_default_instances, TableStruct_streamer_2eproto::offsets,
    file_level_metadata_streamer_2eproto, file_level_enum_descriptors_streamer_2eproto,
    file_level_service_descriptors_streamer_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_streamer_2eproto_getter() {
  return &descriptor_table_streamer_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_streamer_2eproto(&descriptor_table_streamer_2eproto);
namespace streamer {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecorderInfo_RecorderState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_streamer_2eproto);
  return file_level_enum_descriptors_streamer_2eproto[0];
}
bool RecorderInfo_RecorderState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RecorderInfo_RecorderState RecorderInfo::Monitoring;
constexpr RecorderInfo_RecorderState RecorderInfo::Recording;
constexpr RecorderInfo_RecorderState RecorderInfo::Inactive;
constexpr RecorderInfo_RecorderState RecorderInfo::Active;
constexpr RecorderInfo_RecorderState RecorderInfo::RecorderState_MIN;
constexpr RecorderInfo_RecorderState RecorderInfo::RecorderState_MAX;
constexpr int RecorderInfo::RecorderState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecorderInfo_AudioFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_streamer_2eproto);
  return file_level_enum_descriptors_streamer_2eproto[1];
}
bool RecorderInfo_AudioFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RecorderInfo_AudioFormat RecorderInfo::Float32;
constexpr RecorderInfo_AudioFormat RecorderInfo::Signed16;
constexpr RecorderInfo_AudioFormat RecorderInfo::Signed24;
constexpr RecorderInfo_AudioFormat RecorderInfo::Signed32;
constexpr RecorderInfo_AudioFormat RecorderInfo::Unsigned8;
constexpr RecorderInfo_AudioFormat RecorderInfo::AudioFormat_MIN;
constexpr RecorderInfo_AudioFormat RecorderInfo::AudioFormat_MAX;
constexpr int RecorderInfo::AudioFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalInfo_SignalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_streamer_2eproto);
  return file_level_enum_descriptors_streamer_2eproto[2];
}
bool SignalInfo_SignalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SignalInfo_SignalType SignalInfo::Normal;
constexpr SignalInfo_SignalType SignalInfo::Emergency;
constexpr SignalInfo_SignalType SignalInfo::EmergencyAck;
constexpr SignalInfo_SignalType SignalInfo::RadioCheck;
constexpr SignalInfo_SignalType SignalInfo::RadioCheckAck;
constexpr SignalInfo_SignalType SignalInfo::RadioStun;
constexpr SignalInfo_SignalType SignalInfo::RadioStunAck;
constexpr SignalInfo_SignalType SignalInfo::RadioRevive;
constexpr SignalInfo_SignalType SignalInfo::RadioReviveAck;
constexpr SignalInfo_SignalType SignalInfo::NormalPre;
constexpr SignalInfo_SignalType SignalInfo::EmergencyPre;
constexpr SignalInfo_SignalType SignalInfo::SignalType_MIN;
constexpr SignalInfo_SignalType SignalInfo::SignalType_MAX;
constexpr int SignalInfo::SignalType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class AudioSample::_Internal {
 public:
};

AudioSample::AudioSample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.AudioSample)
}
AudioSample::AudioSample(const AudioSample& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioSample* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sample_){}
    , decltype(_impl_.recorder_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sample_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sample().empty()) {
    _this->_impl_.sample_.Set(from._internal_sample(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.recorder_num_ = from._impl_.recorder_num_;
  // @@protoc_insertion_point(copy_constructor:streamer.AudioSample)
}

inline void AudioSample::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sample_){}
    , decltype(_impl_.recorder_num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sample_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AudioSample::~AudioSample() {
  // @@protoc_insertion_point(destructor:streamer.AudioSample)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioSample::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sample_.Destroy();
}

void AudioSample::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioSample::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.AudioSample)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sample_.ClearToEmpty();
  _impl_.recorder_num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioSample::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 recorder_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.recorder_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes sample = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sample();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioSample::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.AudioSample)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 recorder_num = 1;
  if (this->_internal_recorder_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_recorder_num(), target);
  }

  // bytes sample = 2;
  if (!this->_internal_sample().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sample(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.AudioSample)
  return target;
}

size_t AudioSample::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.AudioSample)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes sample = 2;
  if (!this->_internal_sample().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sample());
  }

  // int32 recorder_num = 1;
  if (this->_internal_recorder_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recorder_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioSample::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioSample::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioSample::GetClassData() const { return &_class_data_; }


void AudioSample::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioSample*>(&to_msg);
  auto& from = static_cast<const AudioSample&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.AudioSample)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sample().empty()) {
    _this->_internal_set_sample(from._internal_sample());
  }
  if (from._internal_recorder_num() != 0) {
    _this->_internal_set_recorder_num(from._internal_recorder_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioSample::CopyFrom(const AudioSample& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.AudioSample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioSample::IsInitialized() const {
  return true;
}

void AudioSample::InternalSwap(AudioSample* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sample_, lhs_arena,
      &other->_impl_.sample_, rhs_arena
  );
  swap(_impl_.recorder_num_, other->_impl_.recorder_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioSample::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[0]);
}

// ===================================================================

class RecorderInfo::_Internal {
 public:
};

RecorderInfo::RecorderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.RecorderInfo)
}
RecorderInfo::RecorderInfo(const RecorderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecorderInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recorder_type_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.recorder_num_){}
    , decltype(_impl_.source_num_){}
    , decltype(_impl_.recorder_duration_){}
    , decltype(_impl_.recorder_count_){}
    , decltype(_impl_.recorder_state_){}
    , decltype(_impl_.status_len_){}
    , decltype(_impl_.status_error_){}
    , decltype(_impl_.status_spike_){}
    , decltype(_impl_.audio_sample_rate_){}
    , decltype(_impl_.audio_channels_){}
    , decltype(_impl_.audio_format_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.recorder_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recorder_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_recorder_type().empty()) {
    _this->_impl_.recorder_type_.Set(from._internal_recorder_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.recorder_num_, &from._impl_.recorder_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.audio_format_) -
    reinterpret_cast<char*>(&_impl_.recorder_num_)) + sizeof(_impl_.audio_format_));
  // @@protoc_insertion_point(copy_constructor:streamer.RecorderInfo)
}

inline void RecorderInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recorder_type_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.recorder_num_){0}
    , decltype(_impl_.source_num_){0}
    , decltype(_impl_.recorder_duration_){0}
    , decltype(_impl_.recorder_count_){0}
    , decltype(_impl_.recorder_state_){0}
    , decltype(_impl_.status_len_){0}
    , decltype(_impl_.status_error_){0}
    , decltype(_impl_.status_spike_){0}
    , decltype(_impl_.audio_sample_rate_){0}
    , decltype(_impl_.audio_channels_){0}
    , decltype(_impl_.audio_format_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.recorder_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recorder_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RecorderInfo::~RecorderInfo() {
  // @@protoc_insertion_point(destructor:streamer.RecorderInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecorderInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recorder_type_.Destroy();
  _impl_.id_.Destroy();
}

void RecorderInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecorderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.RecorderInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recorder_type_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  ::memset(&_impl_.recorder_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.audio_format_) -
      reinterpret_cast<char*>(&_impl_.recorder_num_)) + sizeof(_impl_.audio_format_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecorderInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 recorder_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.recorder_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string recorder_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_recorder_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.RecorderInfo.recorder_type"));
        } else
          goto handle_unusual;
        continue;
      // int32 source_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.source_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.RecorderInfo.id"));
        } else
          goto handle_unusual;
        continue;
      // int32 recorder_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.recorder_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double recorder_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.recorder_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .streamer.RecorderInfo.RecorderState recorder_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_recorder_state(static_cast<::streamer::RecorderInfo_RecorderState>(val));
        } else
          goto handle_unusual;
        continue;
      // double status_len = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.status_len_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double status_error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.status_error_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double status_spike = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.status_spike_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 audio_sample_rate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.audio_sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 audio_channels = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.audio_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .streamer.RecorderInfo.AudioFormat audio_format = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_audio_format(static_cast<::streamer::RecorderInfo_AudioFormat>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecorderInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.RecorderInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 recorder_num = 1;
  if (this->_internal_recorder_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_recorder_num(), target);
  }

  // string recorder_type = 2;
  if (!this->_internal_recorder_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_recorder_type().data(), static_cast<int>(this->_internal_recorder_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.RecorderInfo.recorder_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_recorder_type(), target);
  }

  // int32 source_num = 3;
  if (this->_internal_source_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_source_num(), target);
  }

  // string id = 4;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.RecorderInfo.id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_id(), target);
  }

  // int32 recorder_count = 5;
  if (this->_internal_recorder_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_recorder_count(), target);
  }

  // double recorder_duration = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_recorder_duration = this->_internal_recorder_duration();
  uint64_t raw_recorder_duration;
  memcpy(&raw_recorder_duration, &tmp_recorder_duration, sizeof(tmp_recorder_duration));
  if (raw_recorder_duration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_recorder_duration(), target);
  }

  // .streamer.RecorderInfo.RecorderState recorder_state = 7;
  if (this->_internal_recorder_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_recorder_state(), target);
  }

  // double status_len = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_len = this->_internal_status_len();
  uint64_t raw_status_len;
  memcpy(&raw_status_len, &tmp_status_len, sizeof(tmp_status_len));
  if (raw_status_len != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_status_len(), target);
  }

  // double status_error = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_error = this->_internal_status_error();
  uint64_t raw_status_error;
  memcpy(&raw_status_error, &tmp_status_error, sizeof(tmp_status_error));
  if (raw_status_error != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_status_error(), target);
  }

  // double status_spike = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_spike = this->_internal_status_spike();
  uint64_t raw_status_spike;
  memcpy(&raw_status_spike, &tmp_status_spike, sizeof(tmp_status_spike));
  if (raw_status_spike != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_status_spike(), target);
  }

  // int32 audio_sample_rate = 11;
  if (this->_internal_audio_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_audio_sample_rate(), target);
  }

  // int32 audio_channels = 12;
  if (this->_internal_audio_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_audio_channels(), target);
  }

  // .streamer.RecorderInfo.AudioFormat audio_format = 13;
  if (this->_internal_audio_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_audio_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.RecorderInfo)
  return target;
}

size_t RecorderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.RecorderInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string recorder_type = 2;
  if (!this->_internal_recorder_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_recorder_type());
  }

  // string id = 4;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // int32 recorder_num = 1;
  if (this->_internal_recorder_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recorder_num());
  }

  // int32 source_num = 3;
  if (this->_internal_source_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_source_num());
  }

  // double recorder_duration = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_recorder_duration = this->_internal_recorder_duration();
  uint64_t raw_recorder_duration;
  memcpy(&raw_recorder_duration, &tmp_recorder_duration, sizeof(tmp_recorder_duration));
  if (raw_recorder_duration != 0) {
    total_size += 1 + 8;
  }

  // int32 recorder_count = 5;
  if (this->_internal_recorder_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recorder_count());
  }

  // .streamer.RecorderInfo.RecorderState recorder_state = 7;
  if (this->_internal_recorder_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_recorder_state());
  }

  // double status_len = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_len = this->_internal_status_len();
  uint64_t raw_status_len;
  memcpy(&raw_status_len, &tmp_status_len, sizeof(tmp_status_len));
  if (raw_status_len != 0) {
    total_size += 1 + 8;
  }

  // double status_error = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_error = this->_internal_status_error();
  uint64_t raw_status_error;
  memcpy(&raw_status_error, &tmp_status_error, sizeof(tmp_status_error));
  if (raw_status_error != 0) {
    total_size += 1 + 8;
  }

  // double status_spike = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_spike = this->_internal_status_spike();
  uint64_t raw_status_spike;
  memcpy(&raw_status_spike, &tmp_status_spike, sizeof(tmp_status_spike));
  if (raw_status_spike != 0) {
    total_size += 1 + 8;
  }

  // int32 audio_sample_rate = 11;
  if (this->_internal_audio_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audio_sample_rate());
  }

  // int32 audio_channels = 12;
  if (this->_internal_audio_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audio_channels());
  }

  // .streamer.RecorderInfo.AudioFormat audio_format = 13;
  if (this->_internal_audio_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_audio_format());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecorderInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecorderInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecorderInfo::GetClassData() const { return &_class_data_; }


void RecorderInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecorderInfo*>(&to_msg);
  auto& from = static_cast<const RecorderInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.RecorderInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_recorder_type().empty()) {
    _this->_internal_set_recorder_type(from._internal_recorder_type());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_recorder_num() != 0) {
    _this->_internal_set_recorder_num(from._internal_recorder_num());
  }
  if (from._internal_source_num() != 0) {
    _this->_internal_set_source_num(from._internal_source_num());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_recorder_duration = from._internal_recorder_duration();
  uint64_t raw_recorder_duration;
  memcpy(&raw_recorder_duration, &tmp_recorder_duration, sizeof(tmp_recorder_duration));
  if (raw_recorder_duration != 0) {
    _this->_internal_set_recorder_duration(from._internal_recorder_duration());
  }
  if (from._internal_recorder_count() != 0) {
    _this->_internal_set_recorder_count(from._internal_recorder_count());
  }
  if (from._internal_recorder_state() != 0) {
    _this->_internal_set_recorder_state(from._internal_recorder_state());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_len = from._internal_status_len();
  uint64_t raw_status_len;
  memcpy(&raw_status_len, &tmp_status_len, sizeof(tmp_status_len));
  if (raw_status_len != 0) {
    _this->_internal_set_status_len(from._internal_status_len());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_error = from._internal_status_error();
  uint64_t raw_status_error;
  memcpy(&raw_status_error, &tmp_status_error, sizeof(tmp_status_error));
  if (raw_status_error != 0) {
    _this->_internal_set_status_error(from._internal_status_error());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_status_spike = from._internal_status_spike();
  uint64_t raw_status_spike;
  memcpy(&raw_status_spike, &tmp_status_spike, sizeof(tmp_status_spike));
  if (raw_status_spike != 0) {
    _this->_internal_set_status_spike(from._internal_status_spike());
  }
  if (from._internal_audio_sample_rate() != 0) {
    _this->_internal_set_audio_sample_rate(from._internal_audio_sample_rate());
  }
  if (from._internal_audio_channels() != 0) {
    _this->_internal_set_audio_channels(from._internal_audio_channels());
  }
  if (from._internal_audio_format() != 0) {
    _this->_internal_set_audio_format(from._internal_audio_format());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecorderInfo::CopyFrom(const RecorderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.RecorderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecorderInfo::IsInitialized() const {
  return true;
}

void RecorderInfo::InternalSwap(RecorderInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recorder_type_, lhs_arena,
      &other->_impl_.recorder_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecorderInfo, _impl_.audio_format_)
      + sizeof(RecorderInfo::_impl_.audio_format_)
      - PROTOBUF_FIELD_OFFSET(RecorderInfo, _impl_.recorder_num_)>(
          reinterpret_cast<char*>(&_impl_.recorder_num_),
          reinterpret_cast<char*>(&other->_impl_.recorder_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RecorderInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[1]);
}

// ===================================================================

class SourceInfo::_Internal {
 public:
};

SourceInfo::SourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.SourceInfo)
}
SourceInfo::SourceInfo(const SourceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SourceInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.driver_){}
    , decltype(_impl_.device_){}
    , decltype(_impl_.antenna_){}
    , decltype(_impl_.min_hz_){}
    , decltype(_impl_.max_hz_){}
    , decltype(_impl_.center_hz_){}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.source_num_){}
    , decltype(_impl_.mix_gain_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.lna_gain_){}
    , decltype(_impl_.vga1_gain_){}
    , decltype(_impl_.vga2_gain_){}
    , decltype(_impl_.bb_gain_){}
    , decltype(_impl_.gain_){}
    , decltype(_impl_.if_gain_){}
    , decltype(_impl_.analog_recorders_){}
    , decltype(_impl_.digital_recorders_){}
    , decltype(_impl_.debug_recorders_){}
    , decltype(_impl_.sigmf_recorders_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_driver().empty()) {
    _this->_impl_.driver_.Set(from._internal_driver(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device().empty()) {
    _this->_impl_.device_.Set(from._internal_device(), 
      _this->GetArenaForAllocation());
  }
  _impl_.antenna_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.antenna_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_antenna().empty()) {
    _this->_impl_.antenna_.Set(from._internal_antenna(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_hz_, &from._impl_.min_hz_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sigmf_recorders_) -
    reinterpret_cast<char*>(&_impl_.min_hz_)) + sizeof(_impl_.sigmf_recorders_));
  // @@protoc_insertion_point(copy_constructor:streamer.SourceInfo)
}

inline void SourceInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.driver_){}
    , decltype(_impl_.device_){}
    , decltype(_impl_.antenna_){}
    , decltype(_impl_.min_hz_){0}
    , decltype(_impl_.max_hz_){0}
    , decltype(_impl_.center_hz_){0}
    , decltype(_impl_.rate_){0}
    , decltype(_impl_.source_num_){0}
    , decltype(_impl_.mix_gain_){0}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.lna_gain_){0}
    , decltype(_impl_.vga1_gain_){0}
    , decltype(_impl_.vga2_gain_){0}
    , decltype(_impl_.bb_gain_){0}
    , decltype(_impl_.gain_){0}
    , decltype(_impl_.if_gain_){0}
    , decltype(_impl_.analog_recorders_){0}
    , decltype(_impl_.digital_recorders_){0}
    , decltype(_impl_.debug_recorders_){0}
    , decltype(_impl_.sigmf_recorders_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.driver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.antenna_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.antenna_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SourceInfo::~SourceInfo() {
  // @@protoc_insertion_point(destructor:streamer.SourceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SourceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.driver_.Destroy();
  _impl_.device_.Destroy();
  _impl_.antenna_.Destroy();
}

void SourceInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SourceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.SourceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.driver_.ClearToEmpty();
  _impl_.device_.ClearToEmpty();
  _impl_.antenna_.ClearToEmpty();
  ::memset(&_impl_.min_hz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sigmf_recorders_) -
      reinterpret_cast<char*>(&_impl_.min_hz_)) + sizeof(_impl_.sigmf_recorders_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SourceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 source_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double min_hz = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.min_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double max_hz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.max_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double center_hz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.center_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string driver = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_driver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SourceInfo.driver"));
        } else
          goto handle_unusual;
        continue;
      // string device = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SourceInfo.device"));
        } else
          goto handle_unusual;
        continue;
      // string antenna = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_antenna();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SourceInfo.antenna"));
        } else
          goto handle_unusual;
        continue;
      // double error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 mix_gain = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.mix_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 lna_gain = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.lna_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 vga1_gain = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.vga1_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 vga2_gain = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.vga2_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 bb_gain = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.bb_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 gain = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 if_gain = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.if_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 analog_recorders = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.analog_recorders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 digital_recorders = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.digital_recorders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 debug_recorders = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.debug_recorders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sigmf_recorders = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.sigmf_recorders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SourceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.SourceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 source_num = 1;
  if (this->_internal_source_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_source_num(), target);
  }

  // double min_hz = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_min_hz = this->_internal_min_hz();
  uint64_t raw_min_hz;
  memcpy(&raw_min_hz, &tmp_min_hz, sizeof(tmp_min_hz));
  if (raw_min_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_min_hz(), target);
  }

  // double max_hz = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_hz = this->_internal_max_hz();
  uint64_t raw_max_hz;
  memcpy(&raw_max_hz, &tmp_max_hz, sizeof(tmp_max_hz));
  if (raw_max_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_max_hz(), target);
  }

  // double center_hz = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_center_hz = this->_internal_center_hz();
  uint64_t raw_center_hz;
  memcpy(&raw_center_hz, &tmp_center_hz, sizeof(tmp_center_hz));
  if (raw_center_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_center_hz(), target);
  }

  // double rate = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rate = this->_internal_rate();
  uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_rate(), target);
  }

  // string driver = 6;
  if (!this->_internal_driver().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_driver().data(), static_cast<int>(this->_internal_driver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SourceInfo.driver");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_driver(), target);
  }

  // string device = 7;
  if (!this->_internal_device().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_device().data(), static_cast<int>(this->_internal_device().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SourceInfo.device");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_device(), target);
  }

  // string antenna = 8;
  if (!this->_internal_antenna().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_antenna().data(), static_cast<int>(this->_internal_antenna().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SourceInfo.antenna");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_antenna(), target);
  }

  // double error = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_error = this->_internal_error();
  uint64_t raw_error;
  memcpy(&raw_error, &tmp_error, sizeof(tmp_error));
  if (raw_error != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_error(), target);
  }

  // int32 mix_gain = 10;
  if (this->_internal_mix_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_mix_gain(), target);
  }

  // int32 lna_gain = 11;
  if (this->_internal_lna_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_lna_gain(), target);
  }

  // int32 vga1_gain = 12;
  if (this->_internal_vga1_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_vga1_gain(), target);
  }

  // int32 vga2_gain = 13;
  if (this->_internal_vga2_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_vga2_gain(), target);
  }

  // int32 bb_gain = 14;
  if (this->_internal_bb_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_bb_gain(), target);
  }

  // int32 gain = 15;
  if (this->_internal_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_gain(), target);
  }

  // int32 if_gain = 16;
  if (this->_internal_if_gain() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_if_gain(), target);
  }

  // int32 analog_recorders = 17;
  if (this->_internal_analog_recorders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_analog_recorders(), target);
  }

  // int32 digital_recorders = 18;
  if (this->_internal_digital_recorders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_digital_recorders(), target);
  }

  // int32 debug_recorders = 19;
  if (this->_internal_debug_recorders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_debug_recorders(), target);
  }

  // int32 sigmf_recorders = 20;
  if (this->_internal_sigmf_recorders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_sigmf_recorders(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.SourceInfo)
  return target;
}

size_t SourceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.SourceInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string driver = 6;
  if (!this->_internal_driver().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_driver());
  }

  // string device = 7;
  if (!this->_internal_device().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device());
  }

  // string antenna = 8;
  if (!this->_internal_antenna().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_antenna());
  }

  // double min_hz = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_min_hz = this->_internal_min_hz();
  uint64_t raw_min_hz;
  memcpy(&raw_min_hz, &tmp_min_hz, sizeof(tmp_min_hz));
  if (raw_min_hz != 0) {
    total_size += 1 + 8;
  }

  // double max_hz = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_hz = this->_internal_max_hz();
  uint64_t raw_max_hz;
  memcpy(&raw_max_hz, &tmp_max_hz, sizeof(tmp_max_hz));
  if (raw_max_hz != 0) {
    total_size += 1 + 8;
  }

  // double center_hz = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_center_hz = this->_internal_center_hz();
  uint64_t raw_center_hz;
  memcpy(&raw_center_hz, &tmp_center_hz, sizeof(tmp_center_hz));
  if (raw_center_hz != 0) {
    total_size += 1 + 8;
  }

  // double rate = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rate = this->_internal_rate();
  uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    total_size += 1 + 8;
  }

  // int32 source_num = 1;
  if (this->_internal_source_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_source_num());
  }

  // int32 mix_gain = 10;
  if (this->_internal_mix_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mix_gain());
  }

  // double error = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_error = this->_internal_error();
  uint64_t raw_error;
  memcpy(&raw_error, &tmp_error, sizeof(tmp_error));
  if (raw_error != 0) {
    total_size += 1 + 8;
  }

  // int32 lna_gain = 11;
  if (this->_internal_lna_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_lna_gain());
  }

  // int32 vga1_gain = 12;
  if (this->_internal_vga1_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vga1_gain());
  }

  // int32 vga2_gain = 13;
  if (this->_internal_vga2_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vga2_gain());
  }

  // int32 bb_gain = 14;
  if (this->_internal_bb_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bb_gain());
  }

  // int32 gain = 15;
  if (this->_internal_gain() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gain());
  }

  // int32 if_gain = 16;
  if (this->_internal_if_gain() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_if_gain());
  }

  // int32 analog_recorders = 17;
  if (this->_internal_analog_recorders() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_analog_recorders());
  }

  // int32 digital_recorders = 18;
  if (this->_internal_digital_recorders() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_digital_recorders());
  }

  // int32 debug_recorders = 19;
  if (this->_internal_debug_recorders() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_debug_recorders());
  }

  // int32 sigmf_recorders = 20;
  if (this->_internal_sigmf_recorders() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_sigmf_recorders());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SourceInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SourceInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SourceInfo::GetClassData() const { return &_class_data_; }


void SourceInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SourceInfo*>(&to_msg);
  auto& from = static_cast<const SourceInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.SourceInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_driver().empty()) {
    _this->_internal_set_driver(from._internal_driver());
  }
  if (!from._internal_device().empty()) {
    _this->_internal_set_device(from._internal_device());
  }
  if (!from._internal_antenna().empty()) {
    _this->_internal_set_antenna(from._internal_antenna());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_min_hz = from._internal_min_hz();
  uint64_t raw_min_hz;
  memcpy(&raw_min_hz, &tmp_min_hz, sizeof(tmp_min_hz));
  if (raw_min_hz != 0) {
    _this->_internal_set_min_hz(from._internal_min_hz());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_hz = from._internal_max_hz();
  uint64_t raw_max_hz;
  memcpy(&raw_max_hz, &tmp_max_hz, sizeof(tmp_max_hz));
  if (raw_max_hz != 0) {
    _this->_internal_set_max_hz(from._internal_max_hz());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_center_hz = from._internal_center_hz();
  uint64_t raw_center_hz;
  memcpy(&raw_center_hz, &tmp_center_hz, sizeof(tmp_center_hz));
  if (raw_center_hz != 0) {
    _this->_internal_set_center_hz(from._internal_center_hz());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rate = from._internal_rate();
  uint64_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    _this->_internal_set_rate(from._internal_rate());
  }
  if (from._internal_source_num() != 0) {
    _this->_internal_set_source_num(from._internal_source_num());
  }
  if (from._internal_mix_gain() != 0) {
    _this->_internal_set_mix_gain(from._internal_mix_gain());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_error = from._internal_error();
  uint64_t raw_error;
  memcpy(&raw_error, &tmp_error, sizeof(tmp_error));
  if (raw_error != 0) {
    _this->_internal_set_error(from._internal_error());
  }
  if (from._internal_lna_gain() != 0) {
    _this->_internal_set_lna_gain(from._internal_lna_gain());
  }
  if (from._internal_vga1_gain() != 0) {
    _this->_internal_set_vga1_gain(from._internal_vga1_gain());
  }
  if (from._internal_vga2_gain() != 0) {
    _this->_internal_set_vga2_gain(from._internal_vga2_gain());
  }
  if (from._internal_bb_gain() != 0) {
    _this->_internal_set_bb_gain(from._internal_bb_gain());
  }
  if (from._internal_gain() != 0) {
    _this->_internal_set_gain(from._internal_gain());
  }
  if (from._internal_if_gain() != 0) {
    _this->_internal_set_if_gain(from._internal_if_gain());
  }
  if (from._internal_analog_recorders() != 0) {
    _this->_internal_set_analog_recorders(from._internal_analog_recorders());
  }
  if (from._internal_digital_recorders() != 0) {
    _this->_internal_set_digital_recorders(from._internal_digital_recorders());
  }
  if (from._internal_debug_recorders() != 0) {
    _this->_internal_set_debug_recorders(from._internal_debug_recorders());
  }
  if (from._internal_sigmf_recorders() != 0) {
    _this->_internal_set_sigmf_recorders(from._internal_sigmf_recorders());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SourceInfo::CopyFrom(const SourceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.SourceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SourceInfo::IsInitialized() const {
  return true;
}

void SourceInfo::InternalSwap(SourceInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.driver_, lhs_arena,
      &other->_impl_.driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_, lhs_arena,
      &other->_impl_.device_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.antenna_, lhs_arena,
      &other->_impl_.antenna_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SourceInfo, _impl_.sigmf_recorders_)
      + sizeof(SourceInfo::_impl_.sigmf_recorders_)
      - PROTOBUF_FIELD_OFFSET(SourceInfo, _impl_.min_hz_)>(
          reinterpret_cast<char*>(&_impl_.min_hz_),
          reinterpret_cast<char*>(&other->_impl_.min_hz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SourceInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[2]);
}

// ===================================================================

class SystemInfo::_Internal {
 public:
};

SystemInfo::SystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.SystemInfo)
}
SystemInfo::SystemInfo(const SystemInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SystemInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.channels_){from._impl_.channels_}
    , decltype(_impl_.system_type_){}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.talkgroups_file_){}
    , decltype(_impl_.bandplan_){}
    , decltype(_impl_.system_num_){}
    , decltype(_impl_.audio_archive_){}
    , decltype(_impl_.record_unknown_){}
    , decltype(_impl_.call_log_){}
    , decltype(_impl_.qpsk_){}
    , decltype(_impl_.analog_levels_){}
    , decltype(_impl_.digital_levels_){}
    , decltype(_impl_.squelch_db_){}
    , decltype(_impl_.bandplan_base_){}
    , decltype(_impl_.bandplan_high_){}
    , decltype(_impl_.bandfreq_){}
    , decltype(_impl_.bandplan_offset_){}
    , decltype(_impl_.bandplan_spacing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.system_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_system_type().empty()) {
    _this->_impl_.system_type_.Set(from._internal_system_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_system_name().empty()) {
    _this->_impl_.system_name_.Set(from._internal_system_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.talkgroups_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.talkgroups_file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_talkgroups_file().empty()) {
    _this->_impl_.talkgroups_file_.Set(from._internal_talkgroups_file(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bandplan_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandplan_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bandplan().empty()) {
    _this->_impl_.bandplan_.Set(from._internal_bandplan(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.system_num_, &from._impl_.system_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bandplan_spacing_) -
    reinterpret_cast<char*>(&_impl_.system_num_)) + sizeof(_impl_.bandplan_spacing_));
  // @@protoc_insertion_point(copy_constructor:streamer.SystemInfo)
}

inline void SystemInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.channels_){arena}
    , decltype(_impl_.system_type_){}
    , decltype(_impl_.system_name_){}
    , decltype(_impl_.talkgroups_file_){}
    , decltype(_impl_.bandplan_){}
    , decltype(_impl_.system_num_){0}
    , decltype(_impl_.audio_archive_){false}
    , decltype(_impl_.record_unknown_){false}
    , decltype(_impl_.call_log_){false}
    , decltype(_impl_.qpsk_){false}
    , decltype(_impl_.analog_levels_){0}
    , decltype(_impl_.digital_levels_){0}
    , decltype(_impl_.squelch_db_){0}
    , decltype(_impl_.bandplan_base_){0}
    , decltype(_impl_.bandplan_high_){0}
    , decltype(_impl_.bandfreq_){0}
    , decltype(_impl_.bandplan_offset_){0}
    , decltype(_impl_.bandplan_spacing_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.system_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.system_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.talkgroups_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.talkgroups_file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bandplan_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bandplan_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemInfo::~SystemInfo() {
  // @@protoc_insertion_point(destructor:streamer.SystemInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.channels_.~RepeatedField();
  _impl_.system_type_.Destroy();
  _impl_.system_name_.Destroy();
  _impl_.talkgroups_file_.Destroy();
  _impl_.bandplan_.Destroy();
}

void SystemInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.SystemInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channels_.Clear();
  _impl_.system_type_.ClearToEmpty();
  _impl_.system_name_.ClearToEmpty();
  _impl_.talkgroups_file_.ClearToEmpty();
  _impl_.bandplan_.ClearToEmpty();
  ::memset(&_impl_.system_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bandplan_spacing_) -
      reinterpret_cast<char*>(&_impl_.system_num_)) + sizeof(_impl_.bandplan_spacing_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 system_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.system_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string system_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_system_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SystemInfo.system_type"));
        } else
          goto handle_unusual;
        continue;
      // string system_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_system_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SystemInfo.system_name"));
        } else
          goto handle_unusual;
        continue;
      // bool audio_archive = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.audio_archive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool record_unknown = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.record_unknown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool call_log = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.call_log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string talkgroups_file = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_talkgroups_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SystemInfo.talkgroups_file"));
        } else
          goto handle_unusual;
        continue;
      // double analog_levels = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.analog_levels_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double digital_levels = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.digital_levels_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool qpsk = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.qpsk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double squelch_db = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.squelch_db_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double channels = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_channels(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 105) {
          _internal_add_channels(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string bandplan = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_bandplan();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SystemInfo.bandplan"));
        } else
          goto handle_unusual;
        continue;
      // int32 bandfreq = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.bandfreq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double bandplan_base = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _impl_.bandplan_base_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double bandplan_high = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _impl_.bandplan_high_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double bandplan_spacing = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _impl_.bandplan_spacing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 bandplan_offset = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.bandplan_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.SystemInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 system_num = 1;
  if (this->_internal_system_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_system_num(), target);
  }

  // string system_type = 2;
  if (!this->_internal_system_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_system_type().data(), static_cast<int>(this->_internal_system_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SystemInfo.system_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_system_type(), target);
  }

  // string system_name = 3;
  if (!this->_internal_system_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_system_name().data(), static_cast<int>(this->_internal_system_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SystemInfo.system_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_system_name(), target);
  }

  // bool audio_archive = 4;
  if (this->_internal_audio_archive() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_audio_archive(), target);
  }

  // bool record_unknown = 6;
  if (this->_internal_record_unknown() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_record_unknown(), target);
  }

  // bool call_log = 7;
  if (this->_internal_call_log() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_call_log(), target);
  }

  // string talkgroups_file = 8;
  if (!this->_internal_talkgroups_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_talkgroups_file().data(), static_cast<int>(this->_internal_talkgroups_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SystemInfo.talkgroups_file");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_talkgroups_file(), target);
  }

  // double analog_levels = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_analog_levels = this->_internal_analog_levels();
  uint64_t raw_analog_levels;
  memcpy(&raw_analog_levels, &tmp_analog_levels, sizeof(tmp_analog_levels));
  if (raw_analog_levels != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_analog_levels(), target);
  }

  // double digital_levels = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_digital_levels = this->_internal_digital_levels();
  uint64_t raw_digital_levels;
  memcpy(&raw_digital_levels, &tmp_digital_levels, sizeof(tmp_digital_levels));
  if (raw_digital_levels != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_digital_levels(), target);
  }

  // bool qpsk = 11;
  if (this->_internal_qpsk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_qpsk(), target);
  }

  // double squelch_db = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_squelch_db = this->_internal_squelch_db();
  uint64_t raw_squelch_db;
  memcpy(&raw_squelch_db, &tmp_squelch_db, sizeof(tmp_squelch_db));
  if (raw_squelch_db != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_squelch_db(), target);
  }

  // repeated double channels = 13;
  if (this->_internal_channels_size() > 0) {
    target = stream->WriteFixedPacked(13, _internal_channels(), target);
  }

  // string bandplan = 14;
  if (!this->_internal_bandplan().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bandplan().data(), static_cast<int>(this->_internal_bandplan().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SystemInfo.bandplan");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_bandplan(), target);
  }

  // int32 bandfreq = 15;
  if (this->_internal_bandfreq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_bandfreq(), target);
  }

  // double bandplan_base = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_base = this->_internal_bandplan_base();
  uint64_t raw_bandplan_base;
  memcpy(&raw_bandplan_base, &tmp_bandplan_base, sizeof(tmp_bandplan_base));
  if (raw_bandplan_base != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_bandplan_base(), target);
  }

  // double bandplan_high = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_high = this->_internal_bandplan_high();
  uint64_t raw_bandplan_high;
  memcpy(&raw_bandplan_high, &tmp_bandplan_high, sizeof(tmp_bandplan_high));
  if (raw_bandplan_high != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_bandplan_high(), target);
  }

  // double bandplan_spacing = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_spacing = this->_internal_bandplan_spacing();
  uint64_t raw_bandplan_spacing;
  memcpy(&raw_bandplan_spacing, &tmp_bandplan_spacing, sizeof(tmp_bandplan_spacing));
  if (raw_bandplan_spacing != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_bandplan_spacing(), target);
  }

  // int32 bandplan_offset = 19;
  if (this->_internal_bandplan_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_bandplan_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.SystemInfo)
  return target;
}

size_t SystemInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.SystemInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double channels = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_channels_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string system_type = 2;
  if (!this->_internal_system_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_system_type());
  }

  // string system_name = 3;
  if (!this->_internal_system_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_system_name());
  }

  // string talkgroups_file = 8;
  if (!this->_internal_talkgroups_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_talkgroups_file());
  }

  // string bandplan = 14;
  if (!this->_internal_bandplan().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bandplan());
  }

  // int32 system_num = 1;
  if (this->_internal_system_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_system_num());
  }

  // bool audio_archive = 4;
  if (this->_internal_audio_archive() != 0) {
    total_size += 1 + 1;
  }

  // bool record_unknown = 6;
  if (this->_internal_record_unknown() != 0) {
    total_size += 1 + 1;
  }

  // bool call_log = 7;
  if (this->_internal_call_log() != 0) {
    total_size += 1 + 1;
  }

  // bool qpsk = 11;
  if (this->_internal_qpsk() != 0) {
    total_size += 1 + 1;
  }

  // double analog_levels = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_analog_levels = this->_internal_analog_levels();
  uint64_t raw_analog_levels;
  memcpy(&raw_analog_levels, &tmp_analog_levels, sizeof(tmp_analog_levels));
  if (raw_analog_levels != 0) {
    total_size += 1 + 8;
  }

  // double digital_levels = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_digital_levels = this->_internal_digital_levels();
  uint64_t raw_digital_levels;
  memcpy(&raw_digital_levels, &tmp_digital_levels, sizeof(tmp_digital_levels));
  if (raw_digital_levels != 0) {
    total_size += 1 + 8;
  }

  // double squelch_db = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_squelch_db = this->_internal_squelch_db();
  uint64_t raw_squelch_db;
  memcpy(&raw_squelch_db, &tmp_squelch_db, sizeof(tmp_squelch_db));
  if (raw_squelch_db != 0) {
    total_size += 1 + 8;
  }

  // double bandplan_base = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_base = this->_internal_bandplan_base();
  uint64_t raw_bandplan_base;
  memcpy(&raw_bandplan_base, &tmp_bandplan_base, sizeof(tmp_bandplan_base));
  if (raw_bandplan_base != 0) {
    total_size += 2 + 8;
  }

  // double bandplan_high = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_high = this->_internal_bandplan_high();
  uint64_t raw_bandplan_high;
  memcpy(&raw_bandplan_high, &tmp_bandplan_high, sizeof(tmp_bandplan_high));
  if (raw_bandplan_high != 0) {
    total_size += 2 + 8;
  }

  // int32 bandfreq = 15;
  if (this->_internal_bandfreq() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bandfreq());
  }

  // int32 bandplan_offset = 19;
  if (this->_internal_bandplan_offset() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_bandplan_offset());
  }

  // double bandplan_spacing = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_spacing = this->_internal_bandplan_spacing();
  uint64_t raw_bandplan_spacing;
  memcpy(&raw_bandplan_spacing, &tmp_bandplan_spacing, sizeof(tmp_bandplan_spacing));
  if (raw_bandplan_spacing != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SystemInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemInfo::GetClassData() const { return &_class_data_; }


void SystemInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SystemInfo*>(&to_msg);
  auto& from = static_cast<const SystemInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.SystemInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.channels_.MergeFrom(from._impl_.channels_);
  if (!from._internal_system_type().empty()) {
    _this->_internal_set_system_type(from._internal_system_type());
  }
  if (!from._internal_system_name().empty()) {
    _this->_internal_set_system_name(from._internal_system_name());
  }
  if (!from._internal_talkgroups_file().empty()) {
    _this->_internal_set_talkgroups_file(from._internal_talkgroups_file());
  }
  if (!from._internal_bandplan().empty()) {
    _this->_internal_set_bandplan(from._internal_bandplan());
  }
  if (from._internal_system_num() != 0) {
    _this->_internal_set_system_num(from._internal_system_num());
  }
  if (from._internal_audio_archive() != 0) {
    _this->_internal_set_audio_archive(from._internal_audio_archive());
  }
  if (from._internal_record_unknown() != 0) {
    _this->_internal_set_record_unknown(from._internal_record_unknown());
  }
  if (from._internal_call_log() != 0) {
    _this->_internal_set_call_log(from._internal_call_log());
  }
  if (from._internal_qpsk() != 0) {
    _this->_internal_set_qpsk(from._internal_qpsk());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_analog_levels = from._internal_analog_levels();
  uint64_t raw_analog_levels;
  memcpy(&raw_analog_levels, &tmp_analog_levels, sizeof(tmp_analog_levels));
  if (raw_analog_levels != 0) {
    _this->_internal_set_analog_levels(from._internal_analog_levels());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_digital_levels = from._internal_digital_levels();
  uint64_t raw_digital_levels;
  memcpy(&raw_digital_levels, &tmp_digital_levels, sizeof(tmp_digital_levels));
  if (raw_digital_levels != 0) {
    _this->_internal_set_digital_levels(from._internal_digital_levels());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_squelch_db = from._internal_squelch_db();
  uint64_t raw_squelch_db;
  memcpy(&raw_squelch_db, &tmp_squelch_db, sizeof(tmp_squelch_db));
  if (raw_squelch_db != 0) {
    _this->_internal_set_squelch_db(from._internal_squelch_db());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_base = from._internal_bandplan_base();
  uint64_t raw_bandplan_base;
  memcpy(&raw_bandplan_base, &tmp_bandplan_base, sizeof(tmp_bandplan_base));
  if (raw_bandplan_base != 0) {
    _this->_internal_set_bandplan_base(from._internal_bandplan_base());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_high = from._internal_bandplan_high();
  uint64_t raw_bandplan_high;
  memcpy(&raw_bandplan_high, &tmp_bandplan_high, sizeof(tmp_bandplan_high));
  if (raw_bandplan_high != 0) {
    _this->_internal_set_bandplan_high(from._internal_bandplan_high());
  }
  if (from._internal_bandfreq() != 0) {
    _this->_internal_set_bandfreq(from._internal_bandfreq());
  }
  if (from._internal_bandplan_offset() != 0) {
    _this->_internal_set_bandplan_offset(from._internal_bandplan_offset());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bandplan_spacing = from._internal_bandplan_spacing();
  uint64_t raw_bandplan_spacing;
  memcpy(&raw_bandplan_spacing, &tmp_bandplan_spacing, sizeof(tmp_bandplan_spacing));
  if (raw_bandplan_spacing != 0) {
    _this->_internal_set_bandplan_spacing(from._internal_bandplan_spacing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemInfo::CopyFrom(const SystemInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.SystemInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfo::IsInitialized() const {
  return true;
}

void SystemInfo::InternalSwap(SystemInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.channels_.InternalSwap(&other->_impl_.channels_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_type_, lhs_arena,
      &other->_impl_.system_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.system_name_, lhs_arena,
      &other->_impl_.system_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.talkgroups_file_, lhs_arena,
      &other->_impl_.talkgroups_file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bandplan_, lhs_arena,
      &other->_impl_.bandplan_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemInfo, _impl_.bandplan_spacing_)
      + sizeof(SystemInfo::_impl_.bandplan_spacing_)
      - PROTOBUF_FIELD_OFFSET(SystemInfo, _impl_.system_num_)>(
          reinterpret_cast<char*>(&_impl_.system_num_),
          reinterpret_cast<char*>(&other->_impl_.system_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[3]);
}

// ===================================================================

class ConfigInfo::_Internal {
 public:
};

ConfigInfo::ConfigInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.ConfigInfo)
}
ConfigInfo::ConfigInfo(const ConfigInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sources_){from._impl_.sources_}
    , decltype(_impl_.systems_){from._impl_.systems_}
    , decltype(_impl_.capture_dir_){}
    , decltype(_impl_.upload_server_){}
    , decltype(_impl_.instance_id_){}
    , decltype(_impl_.instance_key_){}
    , decltype(_impl_.call_timeout_){}
    , decltype(_impl_.log_file_){}
    , decltype(_impl_.broadcast_signals_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.capture_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.capture_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_capture_dir().empty()) {
    _this->_impl_.capture_dir_.Set(from._internal_capture_dir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.upload_server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.upload_server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_upload_server().empty()) {
    _this->_impl_.upload_server_.Set(from._internal_upload_server(), 
      _this->GetArenaForAllocation());
  }
  _impl_.instance_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_instance_id().empty()) {
    _this->_impl_.instance_id_.Set(from._internal_instance_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.instance_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_instance_key().empty()) {
    _this->_impl_.instance_key_.Set(from._internal_instance_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.call_timeout_, &from._impl_.call_timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.broadcast_signals_) -
    reinterpret_cast<char*>(&_impl_.call_timeout_)) + sizeof(_impl_.broadcast_signals_));
  // @@protoc_insertion_point(copy_constructor:streamer.ConfigInfo)
}

inline void ConfigInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sources_){arena}
    , decltype(_impl_.systems_){arena}
    , decltype(_impl_.capture_dir_){}
    , decltype(_impl_.upload_server_){}
    , decltype(_impl_.instance_id_){}
    , decltype(_impl_.instance_key_){}
    , decltype(_impl_.call_timeout_){0}
    , decltype(_impl_.log_file_){false}
    , decltype(_impl_.broadcast_signals_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.capture_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.capture_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.upload_server_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.upload_server_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instance_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.instance_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfigInfo::~ConfigInfo() {
  // @@protoc_insertion_point(destructor:streamer.ConfigInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sources_.~RepeatedPtrField();
  _impl_.systems_.~RepeatedPtrField();
  _impl_.capture_dir_.Destroy();
  _impl_.upload_server_.Destroy();
  _impl_.instance_id_.Destroy();
  _impl_.instance_key_.Destroy();
}

void ConfigInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.ConfigInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sources_.Clear();
  _impl_.systems_.Clear();
  _impl_.capture_dir_.ClearToEmpty();
  _impl_.upload_server_.ClearToEmpty();
  _impl_.instance_id_.ClearToEmpty();
  _impl_.instance_key_.ClearToEmpty();
  ::memset(&_impl_.call_timeout_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.broadcast_signals_) -
      reinterpret_cast<char*>(&_impl_.call_timeout_)) + sizeof(_impl_.broadcast_signals_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .streamer.SourceInfo sources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .streamer.SystemInfo systems = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_systems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string capture_dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_capture_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.ConfigInfo.capture_dir"));
        } else
          goto handle_unusual;
        continue;
      // string upload_server = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_upload_server();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.ConfigInfo.upload_server"));
        } else
          goto handle_unusual;
        continue;
      // int32 call_timeout = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.call_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool log_file = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.log_file_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string instance_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_instance_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.ConfigInfo.instance_id"));
        } else
          goto handle_unusual;
        continue;
      // string instance_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_instance_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.ConfigInfo.instance_key"));
        } else
          goto handle_unusual;
        continue;
      // bool broadcast_signals = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.broadcast_signals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.ConfigInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .streamer.SourceInfo sources = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sources_size()); i < n; i++) {
    const auto& repfield = this->_internal_sources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .streamer.SystemInfo systems = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_systems_size()); i < n; i++) {
    const auto& repfield = this->_internal_systems(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string capture_dir = 3;
  if (!this->_internal_capture_dir().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_capture_dir().data(), static_cast<int>(this->_internal_capture_dir().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.ConfigInfo.capture_dir");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_capture_dir(), target);
  }

  // string upload_server = 4;
  if (!this->_internal_upload_server().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_upload_server().data(), static_cast<int>(this->_internal_upload_server().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.ConfigInfo.upload_server");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_upload_server(), target);
  }

  // int32 call_timeout = 5;
  if (this->_internal_call_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_call_timeout(), target);
  }

  // bool log_file = 6;
  if (this->_internal_log_file() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_log_file(), target);
  }

  // string instance_id = 7;
  if (!this->_internal_instance_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instance_id().data(), static_cast<int>(this->_internal_instance_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.ConfigInfo.instance_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_instance_id(), target);
  }

  // string instance_key = 8;
  if (!this->_internal_instance_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instance_key().data(), static_cast<int>(this->_internal_instance_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.ConfigInfo.instance_key");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_instance_key(), target);
  }

  // bool broadcast_signals = 9;
  if (this->_internal_broadcast_signals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_broadcast_signals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.ConfigInfo)
  return target;
}

size_t ConfigInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.ConfigInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .streamer.SourceInfo sources = 1;
  total_size += 1UL * this->_internal_sources_size();
  for (const auto& msg : this->_impl_.sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .streamer.SystemInfo systems = 2;
  total_size += 1UL * this->_internal_systems_size();
  for (const auto& msg : this->_impl_.systems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string capture_dir = 3;
  if (!this->_internal_capture_dir().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_capture_dir());
  }

  // string upload_server = 4;
  if (!this->_internal_upload_server().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_upload_server());
  }

  // string instance_id = 7;
  if (!this->_internal_instance_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_instance_id());
  }

  // string instance_key = 8;
  if (!this->_internal_instance_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_instance_key());
  }

  // int32 call_timeout = 5;
  if (this->_internal_call_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_call_timeout());
  }

  // bool log_file = 6;
  if (this->_internal_log_file() != 0) {
    total_size += 1 + 1;
  }

  // bool broadcast_signals = 9;
  if (this->_internal_broadcast_signals() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigInfo::GetClassData() const { return &_class_data_; }


void ConfigInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigInfo*>(&to_msg);
  auto& from = static_cast<const ConfigInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.ConfigInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sources_.MergeFrom(from._impl_.sources_);
  _this->_impl_.systems_.MergeFrom(from._impl_.systems_);
  if (!from._internal_capture_dir().empty()) {
    _this->_internal_set_capture_dir(from._internal_capture_dir());
  }
  if (!from._internal_upload_server().empty()) {
    _this->_internal_set_upload_server(from._internal_upload_server());
  }
  if (!from._internal_instance_id().empty()) {
    _this->_internal_set_instance_id(from._internal_instance_id());
  }
  if (!from._internal_instance_key().empty()) {
    _this->_internal_set_instance_key(from._internal_instance_key());
  }
  if (from._internal_call_timeout() != 0) {
    _this->_internal_set_call_timeout(from._internal_call_timeout());
  }
  if (from._internal_log_file() != 0) {
    _this->_internal_set_log_file(from._internal_log_file());
  }
  if (from._internal_broadcast_signals() != 0) {
    _this->_internal_set_broadcast_signals(from._internal_broadcast_signals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigInfo::CopyFrom(const ConfigInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.ConfigInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigInfo::IsInitialized() const {
  return true;
}

void ConfigInfo::InternalSwap(ConfigInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sources_.InternalSwap(&other->_impl_.sources_);
  _impl_.systems_.InternalSwap(&other->_impl_.systems_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.capture_dir_, lhs_arena,
      &other->_impl_.capture_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.upload_server_, lhs_arena,
      &other->_impl_.upload_server_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.instance_id_, lhs_arena,
      &other->_impl_.instance_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.instance_key_, lhs_arena,
      &other->_impl_.instance_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigInfo, _impl_.broadcast_signals_)
      + sizeof(ConfigInfo::_impl_.broadcast_signals_)
      - PROTOBUF_FIELD_OFFSET(ConfigInfo, _impl_.call_timeout_)>(
          reinterpret_cast<char*>(&_impl_.call_timeout_),
          reinterpret_cast<char*>(&other->_impl_.call_timeout_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[4]);
}

// ===================================================================

class CallInfo::_Internal {
 public:
};

CallInfo::CallInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.CallInfo)
}
CallInfo::CallInfo(const CallInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CallInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.call_active_){}
    , decltype(_impl_.recorder_num_){}
    , decltype(_impl_.curr_freq_){}
    , decltype(_impl_.system_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.call_active_, &from._impl_.call_active_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.system_num_) -
    reinterpret_cast<char*>(&_impl_.call_active_)) + sizeof(_impl_.system_num_));
  // @@protoc_insertion_point(copy_constructor:streamer.CallInfo)
}

inline void CallInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.call_active_){false}
    , decltype(_impl_.recorder_num_){0}
    , decltype(_impl_.curr_freq_){0}
    , decltype(_impl_.system_num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CallInfo::~CallInfo() {
  // @@protoc_insertion_point(destructor:streamer.CallInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CallInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.CallInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.call_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.system_num_) -
      reinterpret_cast<char*>(&_impl_.call_active_)) + sizeof(_impl_.system_num_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool call_active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.call_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 recorder_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.recorder_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 system_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.system_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double curr_freq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.curr_freq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.CallInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool call_active = 1;
  if (this->_internal_call_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_call_active(), target);
  }

  // int32 recorder_num = 2;
  if (this->_internal_recorder_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_recorder_num(), target);
  }

  // int32 system_num = 3;
  if (this->_internal_system_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_system_num(), target);
  }

  // double curr_freq = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_freq = this->_internal_curr_freq();
  uint64_t raw_curr_freq;
  memcpy(&raw_curr_freq, &tmp_curr_freq, sizeof(tmp_curr_freq));
  if (raw_curr_freq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_curr_freq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.CallInfo)
  return target;
}

size_t CallInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.CallInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool call_active = 1;
  if (this->_internal_call_active() != 0) {
    total_size += 1 + 1;
  }

  // int32 recorder_num = 2;
  if (this->_internal_recorder_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recorder_num());
  }

  // double curr_freq = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_freq = this->_internal_curr_freq();
  uint64_t raw_curr_freq;
  memcpy(&raw_curr_freq, &tmp_curr_freq, sizeof(tmp_curr_freq));
  if (raw_curr_freq != 0) {
    total_size += 1 + 8;
  }

  // int32 system_num = 3;
  if (this->_internal_system_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_system_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CallInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallInfo::GetClassData() const { return &_class_data_; }


void CallInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CallInfo*>(&to_msg);
  auto& from = static_cast<const CallInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.CallInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_call_active() != 0) {
    _this->_internal_set_call_active(from._internal_call_active());
  }
  if (from._internal_recorder_num() != 0) {
    _this->_internal_set_recorder_num(from._internal_recorder_num());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_curr_freq = from._internal_curr_freq();
  uint64_t raw_curr_freq;
  memcpy(&raw_curr_freq, &tmp_curr_freq, sizeof(tmp_curr_freq));
  if (raw_curr_freq != 0) {
    _this->_internal_set_curr_freq(from._internal_curr_freq());
  }
  if (from._internal_system_num() != 0) {
    _this->_internal_set_system_num(from._internal_system_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallInfo::CopyFrom(const CallInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.CallInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallInfo::IsInitialized() const {
  return true;
}

void CallInfo::InternalSwap(CallInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CallInfo, _impl_.system_num_)
      + sizeof(CallInfo::_impl_.system_num_)
      - PROTOBUF_FIELD_OFFSET(CallInfo, _impl_.call_active_)>(
          reinterpret_cast<char*>(&_impl_.call_active_),
          reinterpret_cast<char*>(&other->_impl_.call_active_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CallInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[5]);
}

// ===================================================================

class SignalInfo::_Internal {
 public:
  static const ::streamer::CallInfo& call_info(const SignalInfo* msg);
  static const ::streamer::SystemInfo& system_info(const SignalInfo* msg);
  static const ::streamer::RecorderInfo& recorder_info(const SignalInfo* msg);
};

const ::streamer::CallInfo&
SignalInfo::_Internal::call_info(const SignalInfo* msg) {
  return *msg->_impl_.call_info_;
}
const ::streamer::SystemInfo&
SignalInfo::_Internal::system_info(const SignalInfo* msg) {
  return *msg->_impl_.system_info_;
}
const ::streamer::RecorderInfo&
SignalInfo::_Internal::recorder_info(const SignalInfo* msg) {
  return *msg->_impl_.recorder_info_;
}
SignalInfo::SignalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:streamer.SignalInfo)
}
SignalInfo::SignalInfo(const SignalInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignalInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signaling_type_){}
    , decltype(_impl_.call_info_){nullptr}
    , decltype(_impl_.system_info_){nullptr}
    , decltype(_impl_.recorder_info_){nullptr}
    , decltype(_impl_.unit_id_){}
    , decltype(_impl_.signal_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signaling_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signaling_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signaling_type().empty()) {
    _this->_impl_.signaling_type_.Set(from._internal_signaling_type(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_call_info()) {
    _this->_impl_.call_info_ = new ::streamer::CallInfo(*from._impl_.call_info_);
  }
  if (from._internal_has_system_info()) {
    _this->_impl_.system_info_ = new ::streamer::SystemInfo(*from._impl_.system_info_);
  }
  if (from._internal_has_recorder_info()) {
    _this->_impl_.recorder_info_ = new ::streamer::RecorderInfo(*from._impl_.recorder_info_);
  }
  ::memcpy(&_impl_.unit_id_, &from._impl_.unit_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_type_) -
    reinterpret_cast<char*>(&_impl_.unit_id_)) + sizeof(_impl_.signal_type_));
  // @@protoc_insertion_point(copy_constructor:streamer.SignalInfo)
}

inline void SignalInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signaling_type_){}
    , decltype(_impl_.call_info_){nullptr}
    , decltype(_impl_.system_info_){nullptr}
    , decltype(_impl_.recorder_info_){nullptr}
    , decltype(_impl_.unit_id_){int64_t{0}}
    , decltype(_impl_.signal_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.signaling_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signaling_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignalInfo::~SignalInfo() {
  // @@protoc_insertion_point(destructor:streamer.SignalInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignalInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signaling_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.call_info_;
  if (this != internal_default_instance()) delete _impl_.system_info_;
  if (this != internal_default_instance()) delete _impl_.recorder_info_;
}

void SignalInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignalInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:streamer.SignalInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signaling_type_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.call_info_ != nullptr) {
    delete _impl_.call_info_;
  }
  _impl_.call_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.system_info_ != nullptr) {
    delete _impl_.system_info_;
  }
  _impl_.system_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.recorder_info_ != nullptr) {
    delete _impl_.recorder_info_;
  }
  _impl_.recorder_info_ = nullptr;
  ::memset(&_impl_.unit_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.signal_type_) -
      reinterpret_cast<char*>(&_impl_.unit_id_)) + sizeof(_impl_.signal_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignalInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 unit_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.unit_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string signaling_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signaling_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "streamer.SignalInfo.signaling_type"));
        } else
          goto handle_unusual;
        continue;
      // .streamer.SignalInfo.SignalType signal_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_signal_type(static_cast<::streamer::SignalInfo_SignalType>(val));
        } else
          goto handle_unusual;
        continue;
      // .streamer.CallInfo call_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_call_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .streamer.SystemInfo system_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .streamer.RecorderInfo recorder_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_recorder_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignalInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:streamer.SignalInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 unit_id = 1;
  if (this->_internal_unit_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_unit_id(), target);
  }

  // string signaling_type = 2;
  if (!this->_internal_signaling_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_signaling_type().data(), static_cast<int>(this->_internal_signaling_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "streamer.SignalInfo.signaling_type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_signaling_type(), target);
  }

  // .streamer.SignalInfo.SignalType signal_type = 3;
  if (this->_internal_signal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_signal_type(), target);
  }

  // .streamer.CallInfo call_info = 4;
  if (this->_internal_has_call_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::call_info(this),
        _Internal::call_info(this).GetCachedSize(), target, stream);
  }

  // .streamer.SystemInfo system_info = 5;
  if (this->_internal_has_system_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::system_info(this),
        _Internal::system_info(this).GetCachedSize(), target, stream);
  }

  // .streamer.RecorderInfo recorder_info = 6;
  if (this->_internal_has_recorder_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::recorder_info(this),
        _Internal::recorder_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:streamer.SignalInfo)
  return target;
}

size_t SignalInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:streamer.SignalInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string signaling_type = 2;
  if (!this->_internal_signaling_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_signaling_type());
  }

  // .streamer.CallInfo call_info = 4;
  if (this->_internal_has_call_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.call_info_);
  }

  // .streamer.SystemInfo system_info = 5;
  if (this->_internal_has_system_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.system_info_);
  }

  // .streamer.RecorderInfo recorder_info = 6;
  if (this->_internal_has_recorder_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.recorder_info_);
  }

  // int64 unit_id = 1;
  if (this->_internal_unit_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_unit_id());
  }

  // .streamer.SignalInfo.SignalType signal_type = 3;
  if (this->_internal_signal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_signal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignalInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignalInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignalInfo::GetClassData() const { return &_class_data_; }


void SignalInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignalInfo*>(&to_msg);
  auto& from = static_cast<const SignalInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:streamer.SignalInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signaling_type().empty()) {
    _this->_internal_set_signaling_type(from._internal_signaling_type());
  }
  if (from._internal_has_call_info()) {
    _this->_internal_mutable_call_info()->::streamer::CallInfo::MergeFrom(
        from._internal_call_info());
  }
  if (from._internal_has_system_info()) {
    _this->_internal_mutable_system_info()->::streamer::SystemInfo::MergeFrom(
        from._internal_system_info());
  }
  if (from._internal_has_recorder_info()) {
    _this->_internal_mutable_recorder_info()->::streamer::RecorderInfo::MergeFrom(
        from._internal_recorder_info());
  }
  if (from._internal_unit_id() != 0) {
    _this->_internal_set_unit_id(from._internal_unit_id());
  }
  if (from._internal_signal_type() != 0) {
    _this->_internal_set_signal_type(from._internal_signal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignalInfo::CopyFrom(const SignalInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:streamer.SignalInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalInfo::IsInitialized() const {
  return true;
}

void SignalInfo::InternalSwap(SignalInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signaling_type_, lhs_arena,
      &other->_impl_.signaling_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignalInfo, _impl_.signal_type_)
      + sizeof(SignalInfo::_impl_.signal_type_)
      - PROTOBUF_FIELD_OFFSET(SignalInfo, _impl_.call_info_)>(
          reinterpret_cast<char*>(&_impl_.call_info_),
          reinterpret_cast<char*>(&other->_impl_.call_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignalInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_streamer_2eproto_getter, &descriptor_table_streamer_2eproto_once,
      file_level_metadata_streamer_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace streamer
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::streamer::AudioSample*
Arena::CreateMaybeMessage< ::streamer::AudioSample >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::AudioSample >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::RecorderInfo*
Arena::CreateMaybeMessage< ::streamer::RecorderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::RecorderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::SourceInfo*
Arena::CreateMaybeMessage< ::streamer::SourceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::SourceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::SystemInfo*
Arena::CreateMaybeMessage< ::streamer::SystemInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::SystemInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::ConfigInfo*
Arena::CreateMaybeMessage< ::streamer::ConfigInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::ConfigInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::CallInfo*
Arena::CreateMaybeMessage< ::streamer::CallInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::CallInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::streamer::SignalInfo*
Arena::CreateMaybeMessage< ::streamer::SignalInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::streamer::SignalInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
